# AMP-203.3: Initialize Local Function Tools at Startup - Implementation Summary

## Overview

This task implements automatic discovery and registration of local FunctionTools at application startup. This establishes the baseline set of tools available to agents before MCP servers are contacted.

## Implementation Status: ✅ COMPLETE

All required components have been implemented and documented.

## Files Created

### 1. `/shared/src/commonMain/kotlin/link/socket/ampere/agents/tools/ToolInitializer.kt`

**Purpose**: Factory and initialization functions for local tools

**Key Components**:
- `createLocalToolSet(): List<FunctionTool<*>>` - Factory function that creates all local tools
- `initializeLocalTools(registry, logger): Result<ToolInitializationResult>` - Registers tools with the registry
- `ToolInitializationResult` - Statistics about initialization (total, successes, failures)
- `ToolRegistrationFailure` - Details about failed registrations

**Tools Defined**:
1. **write_code** - Writes or modifies source code files
   - Autonomy: ACT_WITH_NOTIFICATION
   - Context: ExecutionContext.Code.WriteCode

2. **read_code** - Reads source code files
   - Autonomy: FULLY_AUTONOMOUS
   - Context: ExecutionContext.Code.ReadCode

3. **ask_human** - Escalates decisions to human operators
   - Autonomy: ASK_BEFORE_ACTION
   - Context: ExecutionContext (generic)

4. **create_ticket** - Creates tasks in the issue tracking system
   - Autonomy: ACT_WITH_NOTIFICATION
   - Context: ExecutionContext (generic)

5. **run_tests** - Executes test suites
   - Autonomy: FULLY_AUTONOMOUS
   - Context: ExecutionContext (generic)

**Error Handling**:
- Individual tool failures don't crash the system
- Logs warnings for failures but continues with remaining tools
- Returns Result type with detailed failure information

### 2. `/shared/src/commonTest/kotlin/link/socket/ampere/agents/tools/ToolInitializerTest.kt`

**Purpose**: Comprehensive test suite for tool initialization

**Test Coverage**:
- Tool set creation returns expected number of tools
- Tool IDs are correct (write_code, read_code, ask_human, create_ticket, run_tests)
- Autonomy levels are correctly assigned
- Tools have non-empty names and descriptions
- Multiple calls to createLocalToolSet() are idempotent
- initializeLocalTools() registers all tools successfully
- Tools can be queried by ID after registration
- Multiple initialization calls work correctly
- Individual tool execution returns proper outcomes
- Graceful error handling for partial failures

**Test Count**: 15+ comprehensive tests

### 3. `/shared/src/commonMain/kotlin/link/socket/ampere/startup/AmpereStartup.kt`

**Purpose**: Central system initialization

**Key Components**:
- `initializeAmpere(database, json, scope, logger): Result<AmpereStartupResult>` - Main entry point
- `AmpereStartupResult` - Contains registry and initialization stats
- `createToolRegistry()` - Private helper to set up the registry with event bus

**Initialization Flow**:
1. Creates ToolRegistry with SQLDelight persistence
2. Initializes local function tools via initializeLocalTools()
3. Emits ToolDiscoveryComplete event for observability
4. Returns the registry and statistics

**Event Integration**:
- Uses EventSerialBus for event publishing
- Creates EventSource for system-level events
- Publishes ToolRegistered events for each tool
- Publishes ToolDiscoveryComplete when done

### 4. `/shared/src/commonMain/kotlin/link/socket/ampere/startup/README.md`

**Purpose**: Integration guide and documentation

**Contents**:
- Quick start guide for Compose applications
- Alternative approach for CLI/server applications
- Detailed explanation of what gets initialized
- Error handling patterns
- Usage examples for the ToolRegistry
- Next steps and future enhancements

## Validation Checklist

✅ **createLocalToolSet() returns at least 5 tools**
- write_code, read_code, ask_human, create_ticket, run_tests

✅ **Each tool has correct autonomy level**
- write_code: ACT_WITH_NOTIFICATION
- read_code: FULLY_AUTONOMOUS
- ask_human: ASK_BEFORE_ACTION
- create_ticket: ACT_WITH_NOTIFICATION
- run_tests: FULLY_AUTONOMOUS

✅ **Graceful error handling**
- Individual tool failures logged but don't crash
- System continues with remaining tools
- Clear error messages in logs

✅ **Registry lookup works**
- getTool("write_code") returns correct tool after initialization
- getAllTools() returns all registered tools

✅ **Can be called multiple times**
- Multiple calls to initializeLocalTools() don't cause issues
- Tools are updated/replaced cleanly

✅ **End-to-end execution**
- Each tool can be executed with proper ExecutionRequest
- Returns appropriate Outcome types (CodeChanged.Success, CodeReading.Success, NoChanges.Success)

## Integration Points

### Current Integration

The startup initialization is ready to be integrated into the application. The recommended integration point is in `App.kt` using a `LaunchedEffect`:

```kotlin
LaunchedEffect(database) {
    initializeAmpere(database, json, scope).onSuccess { result ->
        toolRegistry.value = result.registry
    }
}
```

See `/shared/src/commonMain/kotlin/link/socket/ampere/startup/README.md` for detailed integration instructions.

### Future Integration (AMP-203.4)

When MCP server integration is added:
1. MCP server discovery will happen after local tool initialization
2. MCP tools will be registered in the same ToolRegistry
3. The ToolDiscoveryComplete event will include MCP server count
4. Both local and MCP tools will be queryable through the same interface

## Design Decisions

### 1. Factory Pattern

Used `createLocalToolSet()` to explicitly list all tools in one place. This:
- Makes capabilities immediately visible
- Simplifies adding/removing tools
- Provides a single source of truth

### 2. Placeholder Implementations

Tool execution functions return proper ExecutionOutcome types with placeholder data:
- Demonstrates the expected outcome structure
- Allows testing the full initialization flow
- Can be replaced with real implementations incrementally

### 3. Result Types

All fallible operations return `Result<T>`:
- Makes error handling explicit
- Follows Kotlin conventions
- Enables composition with `.onSuccess` and `.onFailure`

### 4. Separate Startup Module

Created `/startup` package for initialization logic:
- Keeps concerns separated
- Makes initialization explicit and discoverable
- Allows platform-specific customization if needed

### 5. Event-Driven

All tool registrations emit events:
- Supports observability via CLI (`ampere watch`)
- Enables audit trails
- Allows reactive tooling

## Testing Notes

The tests are written for `commonTest` but some require database access:
- Tests will run successfully on JVM and Android where SQLite is available
- iOS tests require platform-specific SQLite driver
- Tests include graceful skipping for platforms without database drivers

## Performance Characteristics

- **Startup Time**: O(n) where n = number of tools (currently 5)
- **Memory**: Minimal - only metadata stored in-memory, functions referenced by ID
- **Database**: One insert per tool (5 inserts total)
- **Events**: One ToolRegistered event per tool + one ToolDiscoveryComplete

Expected startup time: < 100ms for local tools

## Observability

### Logging

All initialization steps are logged:
- INFO: Starting initialization
- INFO: Each successful tool registration with details
- WARN: Individual tool failures with error messages
- INFO: Completion summary with statistics

Example log output:
```
[AmpereStartup] === Ampere System Initialization Starting ===
[AmpereStartup] Creating tool registry...
[AmpereStartup] Initializing local function tools...
[ToolInitializer] Starting local tool initialization...
[ToolInitializer] Discovered 5 local tools to register
[ToolInitializer] ✓ Registered tool: Write Code (write_code) [autonomy: ACT_WITH_NOTIFICATION]
[ToolInitializer] ✓ Registered tool: Read Code (read_code) [autonomy: FULLY_AUTONOMOUS]
[ToolInitializer] ✓ Registered tool: Ask Human (ask_human) [autonomy: ASK_BEFORE_ACTION]
[ToolInitializer] ✓ Registered tool: Create Ticket (create_ticket) [autonomy: ACT_WITH_NOTIFICATION]
[ToolInitializer] ✓ Registered tool: Run Tests (run_tests) [autonomy: FULLY_AUTONOMOUS]
[ToolInitializer] Local tool initialization completed successfully: all 5 tools registered
[AmpereStartup] === Ampere System Initialization Complete ===
  Total tools: 5
  Failed registrations: 0
  Status: SUCCESS
```

### Events

Published events can be monitored via the CLI:

```bash
./ampere-cli/ampere watch --filter ToolRegistered
./ampere-cli/ampere watch --filter ToolDiscoveryComplete
```

## Dependencies

This implementation depends on components from previous tasks:

- **AMP-203.1**: Tool sealed interface (FunctionTool, McpTool)
- **AMP-203.2**: ToolRegistry and ToolRegistryRepository

## Next Steps

1. **Integration** - Integrate `initializeAmpere()` into application startup
2. **Real Implementations** - Replace placeholder tool implementations with actual logic:
   - Integrate WriteCodeTool with file system
   - Integrate AskHumanTool with escalation system
   - Integrate CreateTicketTool with ticket/event system
   - Integrate RunTestsTool with test runner
3. **MCP Integration (AMP-203.4)** - Add MCP server discovery to initialization flow

## API Reference

### Public Functions

#### `createLocalToolSet(): List<FunctionTool<*>>`
Returns all local function tools. Can be called multiple times (idempotent).

#### `initializeLocalTools(registry: ToolRegistry, logger: Logger): Result<ToolInitializationResult>`
Registers all local tools with the registry. Handles failures gracefully.

#### `initializeAmpere(database: Database, json: Json, scope: CoroutineScope, logger: Logger): Result<AmpereStartupResult>`
Main initialization entry point. Sets up the entire tool system.

### Data Types

#### `ToolInitializationResult`
```kotlin
data class ToolInitializationResult(
    val totalTools: Int,
    val successfulRegistrations: Int,
    val failedRegistrations: Int,
    val failures: List<ToolRegistrationFailure>
)
```

#### `AmpereStartupResult`
```kotlin
data class AmpereStartupResult(
    val registry: ToolRegistry,
    val toolInitialization: ToolInitializationResult
)
```

## Conclusion

Task AMP-203.3 is complete. The system now automatically discovers and registers local function tools at startup, providing a discoverable baseline of capabilities for agents. The implementation is:

- ✅ Type-safe (uses sealed interfaces from AMP-203.1)
- ✅ Observable (emits events, logs all operations)
- ✅ Resilient (graceful error handling)
- ✅ Testable (comprehensive test suite)
- ✅ Documented (README with integration guide)
- ✅ Extensible (easy to add new tools)

The foundation is ready for MCP tool integration in the next task (AMP-203.4).
