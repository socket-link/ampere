{
    "repository": "socket-link/ampere",
    "issues": [
        {
            "localId": "demo-blocker-epic",
            "type": "Feature",
            "title": "Demo Blockers: Input Responsiveness and Output Visibility",
            "body": "## Context\n\nThe Jazz Test demo has two critical blockers that prevent effective demonstration:\n\n1. **Input starvation**: During cognitive processing, the TUI becomes unresponsive to keypresses. 'h' for help doesn't work, pane switching is slow, typing after ':' has growing delays, and backspace enters spaces instead of deleting.\n\n2. **Output opacity**: Cognitive phases show completion but there's no visibility into what the agent actually produced (files created, code written, decisions made).\n\nThese must be fixed before any public demoâ€”a demo where you can't interact and can't see results is a screensaver, not a showcase.\n\n## Expected Outcomes\n\n- Keypresses respond within 100ms even during active cognitive processing\n- Agent outputs (files, code, decisions) are visible in the TUI\n- Demo can run smoothly without input lag or mystery about what's happening\n\n## Subtasks\n\n1. Diagnose and fix input thread starvation\n2. Add output visibility to Jazz Test pane\n3. Integration test: Demo scenario runs with responsive input",
            "labels": ["bug", "cli", "demo-blocker", "p0"],
            "parent": null,
            "dependsOn": []
        },
        {
            "localId": "input-starvation-fix",
            "type": "Bug",
            "title": "P0: Fix Input Thread Starvation During Cognitive Processing",
            "body": "## Context\n\nDuring Jazz Test execution, the CLI becomes increasingly unresponsive:\n- 'h' for help doesn't trigger\n- Pane switching (1/2/3 keys) is very slow to respond\n- Typing after ':' has growing delay between keypresses\n- Backspace enters a space character instead of deleting\n\nThis is classic thread starvation: the render loop or cognitive processing is monopolizing the coroutine dispatcher, preventing input handling from executing.\n\n## Symptoms Analysis\n\n**Growing delay pattern**: Suggests input events are being queued but the consumer can't keep up. Each cognitive phase might be blocking without yielding.\n\n**Backspace as space**: This is particularly diagnosticâ€”it suggests raw terminal mode isn't properly configured, OR the input buffer is corrupted, OR escape sequence handling is broken when the system is under load.\n\n## Technical Approach\n\n### Step 1: Identify the Blocking Call\n\n1. Add timing logs around suspected blocking operations:\n   ```kotlin\n   val start = System.currentTimeMillis()\n   // suspected blocking call\n   val elapsed = System.currentTimeMillis() - start\n   if (elapsed > 50) logger.warn(\"Blocking call took ${elapsed}ms\")\n   ```\n\n2. Key suspects:\n   - LLM API calls (should be on IO dispatcher, not Main)\n   - Database queries in SQLDelight\n   - Event serialization/deserialization\n   - Render loop without yield points\n\n### Step 2: Verify Dispatcher Usage\n\n1. Ensure cognitive processing runs on `Dispatchers.IO`:\n   ```kotlin\n   // WRONG: blocks main thread\n   val response = llmClient.complete(prompt)\n   \n   // RIGHT: runs on IO pool\n   val response = withContext(Dispatchers.IO) {\n       llmClient.complete(prompt)\n   }\n   ```\n\n2. Ensure render loop yields regularly:\n   ```kotlin\n   while (running) {\n       render()\n       delay(100) // This MUST actually suspend, not busy-wait\n       yield() // Explicit yield point for input processing\n   }\n   ```\n\n### Step 3: Separate Input Processing\n\n1. Input reading should be on its own coroutine that's never blocked:\n   ```kotlin\n   launch(Dispatchers.IO) {\n       while (running) {\n           val key = terminal.reader().read() // blocking read on IO thread\n           inputChannel.send(key) // non-blocking send to channel\n       }\n   }\n   \n   // Main loop consumes from channel\n   launch(Dispatchers.Main) {\n       inputChannel.consumeEach { key ->\n           handleKeypress(key)\n       }\n   }\n   ```\n\n### Step 4: Fix Backspace Handling\n\n1. Backspace might be sent as different codes depending on terminal:\n   - ASCII 8 (BS)\n   - ASCII 127 (DEL)\n   - Escape sequence `^[[3~`\n\n2. Add explicit handling:\n   ```kotlin\n   when (key) {\n       8, 127 -> handleBackspace()\n       27 -> handleEscapeSequence()\n       // ...\n   }\n   ```\n\n3. Verify JLine3 terminal configuration:\n   ```kotlin\n   terminal.enterRawMode() // Should disable line buffering\n   // Check: terminal.attributes should show -icanon -echo\n   ```\n\n## Validation Criteria\n\n- [ ] 'h' responds within 100ms during active cognitive processing\n- [ ] Pane switching (1/2/3) responds within 100ms\n- [ ] Typing after ':' has no perceptible delay\n- [ ] Backspace deletes characters correctly\n- [ ] No input lag even during LLM API calls\n- [ ] Escape key immediately cancels current operation\n\n## Quick Diagnostic\n\nBefore implementing fixes, add this diagnostic to identify the culprit:\n```kotlin\nfun runWithBlockingDetection() {\n    val checker = launch(Dispatchers.Default) {\n        while (isActive) {\n            val before = System.nanoTime()\n            delay(50)\n            val actual = System.nanoTime() - before\n            if (actual > 100_000_000) { // > 100ms\n                logger.error(\"Main thread blocked for ${actual/1_000_000}ms\")\n            }\n        }\n    }\n    // ... run main loop ...\n}\n```",
            "labels": ["bug", "cli", "demo-blocker", "p0"],
            "parent": "demo-blocker-epic",
            "dependsOn": []
        },
        {
            "localId": "output-visibility",
            "type": "Feature",
            "title": "P0: Add Agent Output Visibility to Jazz Test Pane",
            "body": "## Context\n\nThe Jazz Test pane shows cognitive phases completing (PERCEIVE âœ“, PLAN âœ“, EXECUTE âœ“, LEARN âœ“) but provides no insight into what the agent actually produced. This makes it impossible to evaluate whether the demo is working correctly.\n\nThe biological metaphor: We can see neurons firing but can't observe the muscle movements. The motor output needs to be visible, not just the neural activity.\n\n## Current State\n\nThe Jazz Test pane shows:\n- Elapsed time\n- Ticket ID and Agent name\n- Cognitive cycle phases with completion status\n\nWhat's missing:\n- Files created/modified\n- Code snippets or summaries of what was written\n- Decisions made during planning\n- Errors or warnings encountered\n- Memory/knowledge that was stored\n\n## Objective\n\nAdd output visibility so observers can see what the agent actually produced, not just that it completed phases.\n\n## Design\n\n### Option A: Inline Phase Details\nExpand each completed phase to show key outputs:\n```\nCognitive Cycle\nâ”œâ”€ âœ“ PERCEIVE\nâ”‚    Found: 2 files, 1 test\nâ”œâ”€ âœ“ PLAN  \nâ”‚    Steps: 3 (create file â†’ implement â†’ add test)\nâ”œâ”€ âœ“ EXECUTE\nâ”‚    Created: src/Factorial.kt (12 lines)\nâ”‚    Modified: test/FactorialTest.kt (+8 lines)\nâ””â”€ âœ“ LEARN\n     Stored: \"factorial implementation pattern\"\n```\n\n### Option B: Output Summary Section\nAdd a new section below cognitive cycle:\n```\nCognitive Cycle\nâœ“ PERCEIVE â†’ âœ“ PLAN â†’ âœ“ EXECUTE â†’ âœ“ LEARN\n\nOutputs\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nðŸ“„ Created: src/Factorial.kt\n   fun factorial(n: Int): Long = ...\n\nðŸ§ª Modified: test/FactorialTest.kt  \n   +8 lines (3 test cases)\n\nðŸ’¾ Learned: factorial-recursive-pattern\n```\n\n### Option C: Scrollable Output Log\nMaintain a scrollable log of significant outputs:\n```\n[12:34:01] Created file: src/Factorial.kt\n[12:34:03] Wrote 12 lines of Kotlin\n[12:34:05] Created test: testFactorialZero\n[12:34:06] Created test: testFactorialPositive  \n[12:34:07] Created test: testFactorialLarge\n[12:34:08] Stored knowledge: factorial-pattern\n```\n\n### Recommendation\n\nOption A (Inline Phase Details) balances information density with visual clarity. It leverages the existing cognitive tree structure and doesn't require additional screen real estate.\n\n## Implementation\n\n### Step 1: Capture Outputs During Execution\n\n1. Events already flow through EventSerializerBus. Subscribe to output-relevant events:\n   - `FileCreated`, `FileModified`\n   - `CodeGenerated`\n   - `KnowledgeStored`\n   - `PlanCreated`\n   - `DecisionMade`\n\n2. Aggregate into phase summaries:\n   ```kotlin\n   data class PhaseSummary(\n       val phase: CognitivePhase,\n       val status: PhaseStatus,\n       val outputs: List<OutputSummary>\n   )\n   \n   sealed class OutputSummary {\n       data class FileOutput(val path: String, val action: String, val lines: Int): OutputSummary()\n       data class KnowledgeOutput(val tag: String): OutputSummary()\n       data class PlanOutput(val stepCount: Int, val complexity: String): OutputSummary()\n   }\n   ```\n\n### Step 2: Update Jazz Test State\n\n```kotlin\ndata class JazzTestState(\n    val elapsed: Duration,\n    val ticketId: String,\n    val agentName: String,\n    val phases: List<PhaseSummary>, // Updated to include outputs\n    val isComplete: Boolean\n)\n```\n\n### Step 3: Render Phase Details\n\n```kotlin\nfun renderCognitiveTree(phases: List<PhaseSummary>, width: Int): List<String> {\n    return buildList {\n        phases.forEachIndexed { index, phase ->\n            val isLast = index == phases.lastIndex\n            val prefix = if (isLast) \"â””â”€\" else \"â”œâ”€\"\n            val connector = if (isLast) \"   \" else \"â”‚  \"\n            \n            // Phase header\n            val icon = when (phase.status) {\n                PhaseStatus.COMPLETE -> \"âœ“\".green()\n                PhaseStatus.IN_PROGRESS -> \"âš¡\".yellow()\n                PhaseStatus.PENDING -> \"â—‹\".dim()\n            }\n            add(\"$prefix $icon ${phase.phase.name}\")\n            \n            // Phase outputs (indented)\n            phase.outputs.forEach { output ->\n                add(\"$connector   ${output.render(width - 6)}\")\n            }\n        }\n    }\n}\n\nfun OutputSummary.render(maxWidth: Int): String = when (this) {\n    is FileOutput -> \"$action: ${path.truncateStart(maxWidth - action.length - 2)}\"\n    is KnowledgeOutput -> \"Stored: $tag\"\n    is PlanOutput -> \"Steps: $stepCount ($complexity)\"\n}\n```\n\n## Validation Criteria\n\n- [ ] PERCEIVE phase shows what was discovered (files, context)\n- [ ] PLAN phase shows step count and complexity assessment\n- [ ] EXECUTE phase shows files created/modified with line counts\n- [ ] LEARN phase shows knowledge tags that were stored\n- [ ] Outputs are truncated gracefully at narrow terminal widths\n- [ ] Output information updates in real-time as phases complete\n- [ ] Demo observer can tell if agent is working correctly from TUI alone",
            "labels": ["feature", "cli", "demo-blocker", "p0"],
            "parent": "demo-blocker-epic",
            "dependsOn": []
        },
        {
            "localId": "demo-integration-test",
            "type": "Task",
            "title": "Integration Test: Demo Scenario with Responsive Input",
            "body": "## Context\n\nAfter fixing input starvation and adding output visibility, we need to verify the complete demo scenario works smoothly.\n\n## Objective\n\nCreate a repeatable demo scenario that validates both fixes and can be used for the actual launch recording.\n\n## Demo Scenario\n\n### Setup\n1. Fresh database state (or known seed state)\n2. Terminal at 120x40 minimum\n3. API keys configured\n\n### Script\n```\n1. Launch: ampere test jazz\n2. Observe: TUI renders with EVENT STREAM, JAZZ TEST, AGENT panes\n3. Wait: Agent begins PERCEIVE phase (should happen automatically)\n4. Test Input: Press 'h' - help should appear within 100ms\n5. Test Input: Press '1' then '2' - pane focus should switch responsively  \n6. Test Input: Press ':' and type 'status' - no delay between keypresses\n7. Test Input: Press backspace - should delete, not insert space\n8. Observe: As agent progresses, outputs appear under each phase\n9. Observe: EXECUTE phase shows files being created\n10. Observe: LEARN phase shows knowledge stored\n11. Complete: Agent finishes, status shows COMPLETED\n12. Exit: Press 'q' - exits cleanly\n```\n\n### Validation Checklist\n\n- [ ] All keypresses respond within 100ms\n- [ ] Backspace works correctly\n- [ ] Phase outputs are visible and informative\n- [ ] No green rectangle artifacts\n- [ ] No token count leaking below TUI\n- [ ] Status bar accurately reflects agent state\n- [ ] Clean exit with no error messages\n\n### Recording Notes\n\n- Use asciinema for terminal recording\n- Set font size for readability at 1080p\n- Pre-test exact commands to avoid typos during recording\n- Have a backup plan if agent behaves unexpectedly",
            "labels": ["task", "cli", "demo-blocker", "testing"],
            "parent": "demo-blocker-epic",
            "dependsOn": ["input-starvation-fix", "output-visibility"]
        }
    ]
}
