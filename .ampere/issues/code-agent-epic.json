{
    "repository": "socket-link/ampere",
    "issues": [
        {
            "localId": "code-agent-loop-epic",
            "type": "Feature",
            "title": "Close the Execution Loop: CodeWriterAgent Issue-to-PR Pipeline",
            "body": "## Context\n\nAMPERE now has `ProjectManagerAgent` creating GitHub issues and assigning them to agents. But the loop isn't closed‚Äî`CodeWriterAgent` can write files locally but cannot:\n\n1. Discover issues assigned to it\n2. Claim unassigned issues matching its capabilities\n3. Create branches for work\n4. Commit and push changes\n5. Open pull requests for review\n\nWithout this, agents require human intervention to bridge the gap between \"task assigned\" and \"code merged.\" The system produces tickets but can't consume them.\n\nBiologically, this is completing the **motor cortex to muscle fiber pathway**. The brain (PM) sends signals (issues), but the muscles (CodeWriter) need the neuromuscular junction (Git tools) to actually move (merge code).\n\n## Objective\n\nEnable `CodeWriterAgent` to autonomously:\n1. Query GitHub for issues assigned to it or matching its capabilities\n2. Claim issues by self-assigning\n3. Create feature branches following naming conventions\n4. Implement changes based on issue requirements\n5. Commit changes with conventional commit messages\n6. Push branches and create pull requests\n7. Update issue status throughout the workflow\n8. Request review from QA or other agents\n\n## Expected Outcomes\n\n- CodeWriterAgent perceives assigned issues in its `perceiveState`\n- Agent creates branch `feature/ISSUE-123-short-description` for each issue\n- Code changes are committed with messages referencing the issue\n- PRs are created with description linking to issue\n- Issue status updates as work progresses (In Progress ‚Üí In Review ‚Üí Done)\n- QA agent can be requested as reviewer\n- Full pipeline visible in CLI coordination view\n\n## Technical Constraints\n\n- Git operations via `git` CLI (proven reliable like `gh`)\n- PR creation via `gh pr create`\n- Follow existing Tool/Executor patterns\n- Emit events for all Git operations\n- Handle merge conflicts gracefully (escalate to human)\n- Support conventional commits format\n- Work within existing cognitive loop structure\n\n## The Closed Loop\n\n```\nHuman: \"Implement user authentication\"\n    ‚Üì\nProjectManagerAgent: Creates epic + tasks in GitHub\n    ‚Üì\nCodeWriterAgent: Sees assigned task, claims it\n    ‚Üì\nCodeWriterAgent: Creates branch, implements, commits\n    ‚Üì\nCodeWriterAgent: Pushes, creates PR, requests review\n    ‚Üì\nQualityAssuranceAgent: Reviews PR, approves/requests changes\n    ‚Üì\nCodeWriterAgent: Addresses feedback if needed\n    ‚Üì\nPR merged ‚Üí Issue closed ‚Üí Knowledge stored\n    ‚Üì\nSystem has improved itself\n```\n\n## Subtasks\n\n1. AMP-305.1: Define Git Operation Tools\n2. AMP-305.2: Implement GitCliProvider\n3. AMP-305.3: Implement GitExecutor\n4. AMP-305.4: Add Issue Discovery to CodeWriterAgent perceiveState\n5. AMP-305.5: Implement Issue-to-Branch Workflow in determinePlanForTask\n6. AMP-305.6: Implement Code Generation and Commit in executePlan\n7. AMP-305.7: Implement PR Creation and Review Request\n8. AMP-305.8: Add Issue Status Updates Throughout Workflow\n9. AMP-305.9: Integration Tests - Full Issue-to-PR Pipeline",
            "labels": ["feature"],
            "parent": null,
            "dependsOn": []
        },
        {
            "localId": "code-agent-loop-task-1",
            "type": "Task",
            "title": "AMP-305.1: Define Git Operation Tools",
            "body": "## Context\n\nCodeWriterAgent needs tools for Git operations: branching, committing, pushing, and PR creation. These follow the same Tool abstraction pattern as issue management.\n\n## Objective\n\nDefine the tool types and data classes for Git operations.\n\n## Implementation Details\n\n**File: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/execution/tools/git/GitToolTypes.kt`**\n\n```kotlin\n@Serializable\ndata class BranchCreateRequest(\n    val baseBranch: String = \"main\",\n    val branchName: String,\n    val issueNumber: Int? = null\n)\n\n@Serializable\ndata class CommitRequest(\n    val message: String,\n    val files: List<String> = emptyList(), // Empty = all staged\n    val issueNumber: Int? = null // For message footer\n)\n\n@Serializable\ndata class PushRequest(\n    val branchName: String,\n    val setUpstream: Boolean = true,\n    val force: Boolean = false\n)\n\n@Serializable\ndata class PullRequestCreateRequest(\n    val title: String,\n    val body: String,\n    val baseBranch: String = \"main\",\n    val headBranch: String,\n    val issueNumber: Int? = null, // Auto-link to issue\n    val reviewers: List<String> = emptyList(),\n    val labels: List<String> = emptyList(),\n    val draft: Boolean = false\n)\n\n@Serializable\ndata class CreatedPullRequest(\n    val number: Int,\n    val url: String,\n    val headBranch: String,\n    val baseBranch: String\n)\n\n@Serializable\ndata class GitStatusResult(\n    val branch: String,\n    val ahead: Int,\n    val behind: Int,\n    val staged: List<String>,\n    val modified: List<String>,\n    val untracked: List<String>,\n    val hasConflicts: Boolean\n)\n```\n\n**File: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/execution/tools/git/GitTools.kt`**\n\n```kotlin\ndata class ToolCreateBranch(\n    val request: BranchCreateRequest\n) : Tool<String> { // Returns branch name\n    override val name = \"git_create_branch\"\n    override val autonomyLevel = AgentActionAutonomy.MEDIUM\n}\n\ndata class ToolCommit(\n    val request: CommitRequest  \n) : Tool<String> { // Returns commit SHA\n    override val name = \"git_commit\"\n    override val autonomyLevel = AgentActionAutonomy.MEDIUM\n}\n\ndata class ToolPush(\n    val request: PushRequest\n) : Tool<Unit> {\n    override val name = \"git_push\"\n    override val autonomyLevel = AgentActionAutonomy.MEDIUM\n}\n\ndata class ToolCreatePullRequest(\n    val request: PullRequestCreateRequest\n) : Tool<CreatedPullRequest> {\n    override val name = \"git_create_pr\"\n    override val autonomyLevel = AgentActionAutonomy.MEDIUM\n}\n\ndata class ToolGitStatus(\n    val path: String = \".\"\n) : Tool<GitStatusResult> {\n    override val name = \"git_status\"\n    override val autonomyLevel = AgentActionAutonomy.LOW\n}\n\ndata class ToolStageFiles(\n    val files: List<String> = emptyList() // Empty = stage all\n) : Tool<List<String>> { // Returns staged files\n    override val name = \"git_stage\"\n    override val autonomyLevel = AgentActionAutonomy.LOW\n}\n```\n\n## Validation\n\n- All data classes serialize/deserialize correctly\n- Tools follow existing interface pattern\n- Autonomy levels are appropriate (Git operations are reversible)\n- Request types capture all necessary parameters",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": []
        },
        {
            "localId": "code-agent-loop-task-2",
            "type": "Task",
            "title": "AMP-305.2: Implement GitCliProvider",
            "body": "## Context\n\nLike `GitHubCliProvider` for issues, we need a provider that wraps Git CLI commands for repository operations.\n\n## Objective\n\nImplement `GitCliProvider` that executes git and gh commands for branching, committing, pushing, and PR creation.\n\n## Implementation Details\n\n**File: `ampere-core/src/jvmMain/kotlin/link/socket/ampere/integrations/git/GitCliProvider.kt`**\n\n```kotlin\nclass GitCliProvider(\n    private val workingDirectory: File = File(\".\")\n) {\n    \n    suspend fun validateRepository(): Result<Unit> = runCatching {\n        val result = executeGit(\"status\", \"--porcelain\")\n        if (result.exitCode == 128) {\n            error(\"Not a git repository: ${workingDirectory.absolutePath}\")\n        }\n    }\n    \n    suspend fun getCurrentBranch(): Result<String> = runCatching {\n        val result = executeGit(\"branch\", \"--show-current\")\n        result.stdout.trim()\n    }\n    \n    suspend fun createBranch(request: BranchCreateRequest): Result<String> = runCatching {\n        // Fetch latest\n        executeGit(\"fetch\", \"origin\", request.baseBranch)\n        \n        // Create and checkout branch\n        val result = executeGit(\n            \"checkout\", \"-b\", request.branchName,\n            \"origin/${request.baseBranch}\"\n        )\n        \n        if (result.exitCode != 0) {\n            error(\"Failed to create branch: ${result.stderr}\")\n        }\n        \n        request.branchName\n    }\n    \n    suspend fun getStatus(): Result<GitStatusResult> = runCatching {\n        val branchResult = executeGit(\"branch\", \"--show-current\")\n        val statusResult = executeGit(\"status\", \"--porcelain\")\n        val aheadBehind = executeGit(\"rev-list\", \"--left-right\", \"--count\", \"HEAD...@{u}\")\n        \n        // Parse status output\n        val lines = statusResult.stdout.lines().filter { it.isNotBlank() }\n        val staged = lines.filter { it.startsWith(\"A \") || it.startsWith(\"M \") }\n            .map { it.substring(3) }\n        val modified = lines.filter { it.startsWith(\" M\") || it.startsWith(\"MM\") }\n            .map { it.substring(3) }\n        val untracked = lines.filter { it.startsWith(\"??\") }\n            .map { it.substring(3) }\n        val conflicts = lines.any { it.startsWith(\"UU\") || it.startsWith(\"AA\") }\n        \n        // Parse ahead/behind\n        val (ahead, behind) = aheadBehind.stdout.trim().split(\"\\t\")\n            .map { it.toIntOrNull() ?: 0 }\n        \n        GitStatusResult(\n            branch = branchResult.stdout.trim(),\n            ahead = ahead,\n            behind = behind,\n            staged = staged,\n            modified = modified,\n            untracked = untracked,\n            hasConflicts = conflicts\n        )\n    }\n    \n    suspend fun stageFiles(files: List<String>): Result<List<String>> = runCatching {\n        val args = if (files.isEmpty()) {\n            listOf(\"add\", \"-A\")\n        } else {\n            listOf(\"add\") + files\n        }\n        \n        val result = executeGit(*args.toTypedArray())\n        if (result.exitCode != 0) {\n            error(\"Failed to stage files: ${result.stderr}\")\n        }\n        \n        // Return what was staged\n        val status = getStatus().getOrThrow()\n        status.staged\n    }\n    \n    suspend fun commit(request: CommitRequest): Result<String> = runCatching {\n        // Build commit message with optional issue reference\n        val message = buildString {\n            append(request.message)\n            if (request.issueNumber != null) {\n                append(\"\\n\\nRefs #${request.issueNumber}\")\n            }\n        }\n        \n        val result = executeGit(\"commit\", \"-m\", message)\n        \n        if (result.exitCode != 0) {\n            error(\"Failed to commit: ${result.stderr}\")\n        }\n        \n        // Get commit SHA\n        val shaResult = executeGit(\"rev-parse\", \"HEAD\")\n        shaResult.stdout.trim().take(8)\n    }\n    \n    suspend fun push(request: PushRequest): Result<Unit> = runCatching {\n        val args = mutableListOf(\"push\")\n        \n        if (request.setUpstream) {\n            args.addAll(listOf(\"-u\", \"origin\", request.branchName))\n        }\n        \n        if (request.force) {\n            args.add(\"--force-with-lease\")\n        }\n        \n        val result = executeGit(*args.toTypedArray())\n        \n        if (result.exitCode != 0) {\n            error(\"Failed to push: ${result.stderr}\")\n        }\n    }\n    \n    suspend fun createPullRequest(request: PullRequestCreateRequest): Result<CreatedPullRequest> = runCatching {\n        val args = mutableListOf(\n            \"pr\", \"create\",\n            \"--title\", request.title,\n            \"--body\", buildPRBody(request),\n            \"--base\", request.baseBranch,\n            \"--head\", request.headBranch\n        )\n        \n        if (request.draft) {\n            args.add(\"--draft\")\n        }\n        \n        request.reviewers.forEach { \n            args.addAll(listOf(\"--reviewer\", it))\n        }\n        \n        request.labels.forEach {\n            args.addAll(listOf(\"--label\", it))\n        }\n        \n        val result = executeGh(*args.toTypedArray())\n        \n        if (result.exitCode != 0) {\n            error(\"Failed to create PR: ${result.stderr}\")\n        }\n        \n        // Parse PR URL to get number\n        val url = result.stdout.trim()\n        val prNumber = url.substringAfterLast(\"/\").toInt()\n        \n        CreatedPullRequest(\n            number = prNumber,\n            url = url,\n            headBranch = request.headBranch,\n            baseBranch = request.baseBranch\n        )\n    }\n    \n    private fun buildPRBody(request: PullRequestCreateRequest): String = buildString {\n        append(request.body)\n        if (request.issueNumber != null) {\n            append(\"\\n\\n---\\nCloses #${request.issueNumber}\")\n        }\n    }\n    \n    private suspend fun executeGit(vararg args: String) = execute(\"git\", *args)\n    private suspend fun executeGh(vararg args: String) = execute(\"gh\", *args)\n    \n    private suspend fun execute(command: String, vararg args: String): CommandResult = \n        withContext(Dispatchers.IO) {\n            val process = ProcessBuilder(command, *args)\n                .directory(workingDirectory)\n                .redirectErrorStream(false)\n                .start()\n            \n            CommandResult(\n                exitCode = process.waitFor(),\n                stdout = process.inputStream.bufferedReader().readText(),\n                stderr = process.errorStream.bufferedReader().readText()\n            )\n        }\n}\n```\n\n## Validation\n\n- `createBranch` creates branch from base and checks it out\n- `getStatus` correctly parses staged/modified/untracked files\n- `commit` includes issue reference in message footer\n- `push` sets upstream on first push\n- `createPullRequest` links to issue with \"Closes #N\"\n- All operations handle errors gracefully",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-1"]
        },
        {
            "localId": "code-agent-loop-task-3",
            "type": "Task",
            "title": "AMP-305.3: Implement GitExecutor",
            "body": "## Context\n\nFollowing the Executor pattern, we need an executor that handles Git tool invocations and emits appropriate events.\n\n## Objective\n\nImplement `GitExecutor` that processes Git tools and provides observability.\n\n## Implementation Details\n\n**File: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/execution/executors/GitExecutor.kt`**\n\n```kotlin\nclass GitExecutor(\n    private val gitProvider: GitCliProvider,\n    private val eventBus: EventSerializerBus\n) : Executor {\n    \n    override suspend fun canExecute(tool: Tool<*>): Boolean {\n        return tool is ToolCreateBranch ||\n               tool is ToolCommit ||\n               tool is ToolPush ||\n               tool is ToolCreatePullRequest ||\n               tool is ToolGitStatus ||\n               tool is ToolStageFiles\n    }\n    \n    override suspend fun execute(request: ExecutionRequest<*>): ExecutionOutcome {\n        return when (val tool = request.tool) {\n            is ToolCreateBranch -> executeBranchCreate(tool, request)\n            is ToolCommit -> executeCommit(tool, request)\n            is ToolPush -> executePush(tool, request)\n            is ToolCreatePullRequest -> executePRCreate(tool, request)\n            is ToolGitStatus -> executeStatus(tool, request)\n            is ToolStageFiles -> executeStage(tool, request)\n            else -> ExecutionOutcome.Failure(\n                error = \"Unsupported tool: ${tool::class.simpleName}\",\n                tool = tool,\n                request = request\n            )\n        }\n    }\n    \n    private suspend fun executeBranchCreate(\n        tool: ToolCreateBranch,\n        request: ExecutionRequest<*>\n    ): ExecutionOutcome {\n        eventBus.publish(GitBranchCreatingEvent(\n            agentId = request.agentId,\n            branchName = tool.request.branchName,\n            baseBranch = tool.request.baseBranch,\n            issueNumber = tool.request.issueNumber\n        ))\n        \n        return gitProvider.createBranch(tool.request).fold(\n            onSuccess = { branchName ->\n                eventBus.publish(GitBranchCreatedEvent(\n                    agentId = request.agentId,\n                    branchName = branchName\n                ))\n                ExecutionOutcome.Success(result = branchName, tool = tool, request = request)\n            },\n            onFailure = { error ->\n                eventBus.publish(GitOperationFailedEvent(\n                    agentId = request.agentId,\n                    operation = \"createBranch\",\n                    error = error.message ?: \"Unknown error\"\n                ))\n                ExecutionOutcome.Failure(\n                    error = error.message ?: \"Branch creation failed\",\n                    tool = tool,\n                    request = request\n                )\n            }\n        )\n    }\n    \n    private suspend fun executeCommit(\n        tool: ToolCommit,\n        request: ExecutionRequest<*>\n    ): ExecutionOutcome {\n        eventBus.publish(GitCommittingEvent(\n            agentId = request.agentId,\n            message = tool.request.message,\n            issueNumber = tool.request.issueNumber\n        ))\n        \n        return gitProvider.commit(tool.request).fold(\n            onSuccess = { sha ->\n                eventBus.publish(GitCommittedEvent(\n                    agentId = request.agentId,\n                    sha = sha,\n                    message = tool.request.message\n                ))\n                ExecutionOutcome.Success(result = sha, tool = tool, request = request)\n            },\n            onFailure = { error ->\n                ExecutionOutcome.Failure(\n                    error = error.message ?: \"Commit failed\",\n                    tool = tool,\n                    request = request\n                )\n            }\n        )\n    }\n    \n    private suspend fun executePush(\n        tool: ToolPush,\n        request: ExecutionRequest<*>\n    ): ExecutionOutcome {\n        eventBus.publish(GitPushingEvent(\n            agentId = request.agentId,\n            branchName = tool.request.branchName\n        ))\n        \n        return gitProvider.push(tool.request).fold(\n            onSuccess = {\n                eventBus.publish(GitPushedEvent(\n                    agentId = request.agentId,\n                    branchName = tool.request.branchName\n                ))\n                ExecutionOutcome.Success(result = Unit, tool = tool, request = request)\n            },\n            onFailure = { error ->\n                ExecutionOutcome.Failure(\n                    error = error.message ?: \"Push failed\",\n                    tool = tool,\n                    request = request\n                )\n            }\n        )\n    }\n    \n    private suspend fun executePRCreate(\n        tool: ToolCreatePullRequest,\n        request: ExecutionRequest<*>\n    ): ExecutionOutcome {\n        eventBus.publish(PullRequestCreatingEvent(\n            agentId = request.agentId,\n            title = tool.request.title,\n            issueNumber = tool.request.issueNumber\n        ))\n        \n        return gitProvider.createPullRequest(tool.request).fold(\n            onSuccess = { pr ->\n                eventBus.publish(PullRequestCreatedEvent(\n                    agentId = request.agentId,\n                    prNumber = pr.number,\n                    url = pr.url,\n                    issueNumber = tool.request.issueNumber\n                ))\n                ExecutionOutcome.Success(result = pr, tool = tool, request = request)\n            },\n            onFailure = { error ->\n                ExecutionOutcome.Failure(\n                    error = error.message ?: \"PR creation failed\",\n                    tool = tool,\n                    request = request\n                )\n            }\n        )\n    }\n    \n    // Similar implementations for status and stage...\n}\n```\n\nDefine Git events:\n\n```kotlin\n// GitEvents.kt\nsealed interface GitEvent : Event {\n    val agentId: AgentId\n}\n\ndata class GitBranchCreatingEvent(...) : GitEvent\ndata class GitBranchCreatedEvent(...) : GitEvent\ndata class GitCommittingEvent(...) : GitEvent\ndata class GitCommittedEvent(...) : GitEvent\ndata class GitPushingEvent(...) : GitEvent  \ndata class GitPushedEvent(...) : GitEvent\ndata class PullRequestCreatingEvent(...) : GitEvent\ndata class PullRequestCreatedEvent(...) : GitEvent\ndata class GitOperationFailedEvent(...) : GitEvent\n```\n\n## Validation\n\n- Each Git operation emits before/after events\n- Failures emit failure events with details\n- All events include agentId for observability\n- Executor routes to correct provider methods",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-2"]
        },
        {
            "localId": "code-agent-loop-task-4",
            "type": "Task",
            "title": "AMP-305.4: Add Issue Discovery to CodeWriterAgent perceiveState",
            "body": "## Context\n\nCodeWriterAgent needs to see issues assigned to it (or available for claiming) as part of its perception. This is how the agent discovers work to do.\n\n## Objective\n\nEnhance `CodeWriterAgent.perceiveState` to query GitHub for relevant issues and incorporate them into the agent's world model.\n\n## Implementation Details\n\nUpdate CodeWriterAgent's perceiveState:\n\n```kotlin\noverride suspend fun perceiveState(vararg newIdeas: Idea): Idea {\n    // 1. Get issues assigned to this agent\n    val assignedIssues = queryAssignedIssues()\n    \n    // 2. Get unassigned issues matching our capabilities\n    val availableIssues = queryAvailableIssues()\n    \n    // 3. Get current Git status\n    val gitStatus = getGitStatus()\n    \n    // 4. Check for open PRs we created\n    val openPRs = queryOpenPRs()\n    \n    // 5. Get recent events relevant to our work\n    val relevantEvents = eventBus.recentEvents(limit = 30)\n        .filter { it.involvesAgent(id) || it.isTaskRelated() }\n    \n    // 6. Recall relevant past experiences\n    val experiences = recallRelevantExperiences(\n        query = \"code implementation task completion\"\n    )\n    \n    // 7. Build perception\n    val perception = CodeWriterPerception(\n        assignedIssues = assignedIssues,\n        availableIssues = availableIssues,\n        currentBranch = gitStatus?.branch,\n        uncommittedChanges = gitStatus?.modified?.isNotEmpty() ?: false,\n        openPRs = openPRs,\n        hasActiveWork = assignedIssues.any { it.state == IssueState.Open },\n        timestamp = Clock.System.now()\n    )\n    \n    // 8. Synthesize with LLM\n    return runLLMToEvaluatePerception(perception, newIdeas.toList())\n}\n\nprivate suspend fun queryAssignedIssues(): List<ExistingIssue> {\n    val result = issueExecutor.execute(\n        ExecutionRequest(\n            tool = ToolQueryIssues(IssueQuery(\n                assignee = \"CodeWriterAgent\", // Or GitHub username mapping\n                state = IssueState.Open,\n                labels = listOf(\"task\")\n            )),\n            agentId = id\n        )\n    )\n    return (result.getOrNull()?.result as? List<ExistingIssue>) ?: emptyList()\n}\n\nprivate suspend fun queryAvailableIssues(): List<ExistingIssue> {\n    val result = issueExecutor.execute(\n        ExecutionRequest(\n            tool = ToolQueryIssues(IssueQuery(\n                state = IssueState.Open,\n                labels = listOf(\"task\", \"code\"), // Issues matching our skills\n                assignee = null // Unassigned\n            )),\n            agentId = id\n        )\n    )\n    return (result.getOrNull()?.result as? List<ExistingIssue>) ?: emptyList()\n}\n\ndata class CodeWriterPerception(\n    val assignedIssues: List<ExistingIssue>,\n    val availableIssues: List<ExistingIssue>,\n    val currentBranch: String?,\n    val uncommittedChanges: Boolean,\n    val openPRs: List<PullRequest>,\n    val hasActiveWork: Boolean,\n    val timestamp: Instant\n)\n```\n\n## Validation\n\n- perceiveState queries GitHub for assigned issues\n- Unassigned issues with matching labels are discovered\n- Git status is incorporated into perception\n- Open PRs are tracked\n- LLM synthesis produces actionable insights",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-3"]
        },
        {
            "localId": "code-agent-loop-task-5",
            "type": "Task",
            "title": "AMP-305.5: Implement Issue-to-Branch Workflow in determinePlanForTask",
            "body": "## Context\n\nWhen CodeWriterAgent perceives an assigned issue, it needs to plan the complete workflow: claim issue, create branch, implement, commit, push, create PR.\n\n## Objective\n\nImplement `determinePlanForTask` to generate comprehensive implementation plans from issue requirements.\n\n## Implementation Details\n\n```kotlin\noverride suspend fun determinePlanForTask(task: Task, vararg ideas: Idea): Plan {\n    return when (task.type) {\n        TaskType.IMPLEMENT_ISSUE -> createImplementationPlan(task, ideas.toList())\n        TaskType.ADDRESS_PR_FEEDBACK -> createFeedbackPlan(task, ideas.toList())\n        TaskType.CLAIM_ISSUE -> createClaimPlan(task)\n        else -> createGenericPlan(task, ideas.toList())\n    }\n}\n\nprivate suspend fun createImplementationPlan(\n    task: Task,\n    ideas: List<Idea>\n): Plan {\n    val issue = task.metadata[\"issue\"] as ExistingIssue\n    \n    // 1. Analyze issue requirements\n    val analysisPrompt = buildAnalysisPrompt(issue)\n    val analysis = llmClient.complete(analysisPrompt)\n    val requirements = parseRequirements(analysis)\n    \n    // 2. Determine branch name\n    val branchName = generateBranchName(issue)\n    \n    // 3. Build implementation steps via LLM\n    val implementationPrompt = buildImplementationPrompt(issue, requirements)\n    val implementationPlan = llmClient.complete(implementationPrompt)\n    val codeChanges = parseCodeChanges(implementationPlan)\n    \n    // 4. Construct plan steps\n    val steps = mutableListOf<PlanStep>()\n    \n    // Step 1: Update issue status to In Progress\n    steps.add(PlanStep(\n        description = \"Mark issue as in progress\",\n        tool = ToolUpdateIssue(UpdateIssueRequest(\n            issueNumber = issue.number,\n            addLabels = listOf(\"in-progress\")\n        )),\n        expectedOutcome = \"Issue marked as in progress\"\n    ))\n    \n    // Step 2: Create feature branch\n    steps.add(PlanStep(\n        description = \"Create feature branch\",\n        tool = ToolCreateBranch(BranchCreateRequest(\n            branchName = branchName,\n            baseBranch = \"main\",\n            issueNumber = issue.number\n        )),\n        expectedOutcome = \"Branch $branchName created\"\n    ))\n    \n    // Step 3+: Implement each code change\n    codeChanges.forEach { change ->\n        steps.add(PlanStep(\n            description = \"Implement: ${change.description}\",\n            tool = ToolWriteCodeFile(WriteCodeRequest(\n                filePath = change.filePath,\n                content = change.content,\n                operation = change.operation // CREATE, MODIFY, DELETE\n            )),\n            expectedOutcome = \"File ${change.filePath} updated\"\n        ))\n    }\n    \n    // Step N-3: Stage all changes\n    steps.add(PlanStep(\n        description = \"Stage changes\",\n        tool = ToolStageFiles(emptyList()), // Stage all\n        expectedOutcome = \"All changes staged\"\n    ))\n    \n    // Step N-2: Commit with conventional message\n    val commitMessage = generateCommitMessage(issue, codeChanges)\n    steps.add(PlanStep(\n        description = \"Commit changes\",\n        tool = ToolCommit(CommitRequest(\n            message = commitMessage,\n            issueNumber = issue.number\n        )),\n        expectedOutcome = \"Changes committed\"\n    ))\n    \n    // Step N-1: Push branch\n    steps.add(PlanStep(\n        description = \"Push branch\",\n        tool = ToolPush(PushRequest(branchName = branchName)),\n        expectedOutcome = \"Branch pushed to origin\"\n    ))\n    \n    // Step N: Create PR\n    steps.add(PlanStep(\n        description = \"Create pull request\",\n        tool = ToolCreatePullRequest(PullRequestCreateRequest(\n            title = generatePRTitle(issue),\n            body = generatePRBody(issue, codeChanges),\n            headBranch = branchName,\n            issueNumber = issue.number,\n            reviewers = listOf(\"QualityAssuranceAgent\")\n        )),\n        expectedOutcome = \"PR created and review requested\"\n    ))\n    \n    return Plan(\n        goal = \"Implement ${issue.title}\",\n        steps = steps,\n        estimatedDuration = estimateDuration(codeChanges),\n        confidence = calculateConfidence(requirements, codeChanges),\n        metadata = mapOf(\n            \"issueNumber\" to issue.number,\n            \"branchName\" to branchName\n        )\n    )\n}\n\nprivate fun generateBranchName(issue: ExistingIssue): String {\n    val slug = issue.title\n        .lowercase()\n        .replace(Regex(\"[^a-z0-9]+\"), \"-\")\n        .take(40)\n        .trim('-')\n    return \"feature/${issue.number}-$slug\"\n}\n\nprivate fun generateCommitMessage(issue: ExistingIssue, changes: List<CodeChange>): String {\n    val type = when {\n        changes.all { it.operation == FileOperation.CREATE } -> \"feat\"\n        changes.any { it.filePath.contains(\"test\") } -> \"test\"\n        else -> \"feat\"\n    }\n    val scope = detectScope(changes)\n    val description = issue.title.lowercase().take(50)\n    \n    return \"$type($scope): $description\"\n}\n```\n\n## Validation\n\n- Plan includes all steps from issue claim to PR creation\n- Branch names follow convention: `feature/123-short-description`\n- Commit messages follow conventional commits format\n- PR body links to issue with \"Closes #N\"\n- QA agent is added as reviewer",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-4"]
        },
        {
            "localId": "code-agent-loop-task-6",
            "type": "Task",
            "title": "AMP-305.6: Implement Code Generation and Commit in executePlan",
            "body": "## Context\n\nThe plan contains steps for writing code, staging, and committing. `executePlan` needs to execute these in order, handling the code generation aspect through LLM.\n\n## Objective\n\nImplement `executePlan` to execute implementation plans, including LLM-driven code generation.\n\n## Implementation Details\n\n```kotlin\noverride suspend fun executePlan(plan: Plan): Outcome {\n    val stepOutcomes = mutableListOf<StepOutcome>()\n    val context = ExecutionContext(\n        issueNumber = plan.metadata[\"issueNumber\"] as? Int,\n        branchName = plan.metadata[\"branchName\"] as? String,\n        createdFiles = mutableListOf(),\n        modifiedFiles = mutableListOf()\n    )\n    \n    for ((index, step) in plan.steps.withIndex()) {\n        eventBus.publish(ExecutionStepStartedEvent(\n            agentId = id,\n            stepIndex = index,\n            description = step.description,\n            totalSteps = plan.steps.size\n        ))\n        \n        val outcome = try {\n            executeStep(step, context)\n        } catch (e: Exception) {\n            StepOutcome.Failure(\n                message = e.message ?: \"Unknown error\",\n                exception = e,\n                recoverable = isRecoverable(e)\n            )\n        }\n        \n        stepOutcomes.add(outcome)\n        \n        eventBus.publish(ExecutionStepCompletedEvent(\n            agentId = id,\n            stepIndex = index,\n            success = outcome.isSuccess,\n            summary = outcome.summary\n        ))\n        \n        // Handle failures\n        when {\n            outcome is StepOutcome.Failure && !outcome.recoverable -> {\n                // Critical failure - abort and potentially rollback\n                return Outcome(\n                    plan = plan,\n                    stepOutcomes = stepOutcomes,\n                    success = false,\n                    summary = \"Failed at step ${index + 1}: ${outcome.message}\",\n                    requiresHumanIntervention = true\n                )\n            }\n            outcome is StepOutcome.Failure && outcome.recoverable -> {\n                // Try to recover or skip\n                val recovery = attemptRecovery(step, outcome, context)\n                if (!recovery.success) {\n                    stepOutcomes.add(recovery)\n                }\n            }\n        }\n    }\n    \n    return Outcome(\n        plan = plan,\n        stepOutcomes = stepOutcomes,\n        success = stepOutcomes.all { it.isSuccess },\n        summary = generateOutcomeSummary(stepOutcomes, context)\n    )\n}\n\nprivate suspend fun executeStep(\n    step: PlanStep,\n    context: ExecutionContext\n): StepOutcome {\n    return when (val tool = step.tool) {\n        is ToolWriteCodeFile -> executeCodeWrite(tool, context)\n        is ToolCreateBranch -> executeWithGitExecutor(tool)\n        is ToolStageFiles -> executeWithGitExecutor(tool)\n        is ToolCommit -> executeWithGitExecutor(tool)\n        is ToolPush -> executeWithGitExecutor(tool)\n        is ToolCreatePullRequest -> executeWithGitExecutor(tool)\n        is ToolUpdateIssue -> executeWithIssueExecutor(tool)\n        else -> StepOutcome.Skipped(\"Unknown tool type\")\n    }\n}\n\nprivate suspend fun executeCodeWrite(\n    tool: ToolWriteCodeFile,\n    context: ExecutionContext\n): StepOutcome {\n    // If content is a placeholder, generate via LLM\n    val content = if (tool.request.content.startsWith(\"{{GENERATE}}\")) {\n        generateCode(tool.request, context)\n    } else {\n        tool.request.content\n    }\n    \n    // Write the file\n    val result = fileExecutor.execute(\n        ExecutionRequest(\n            tool = tool.copy(request = tool.request.copy(content = content)),\n            agentId = id\n        )\n    )\n    \n    return when (result) {\n        is ExecutionOutcome.Success -> {\n            context.createdFiles.add(tool.request.filePath)\n            StepOutcome.Success(\"Wrote ${tool.request.filePath}\")\n        }\n        is ExecutionOutcome.Failure -> {\n            StepOutcome.Failure(result.error, recoverable = true)\n        }\n        else -> StepOutcome.Failure(\"Unexpected outcome\", recoverable = false)\n    }\n}\n\nprivate suspend fun generateCode(\n    request: WriteCodeRequest,\n    context: ExecutionContext\n): String {\n    val prompt = buildCodeGenerationPrompt(\n        filePath = request.filePath,\n        requirements = request.metadata[\"requirements\"] as? String ?: \"\",\n        existingFiles = context.createdFiles + context.modifiedFiles,\n        issueContext = context.issueNumber?.let { queryIssue(it) }\n    )\n    \n    val response = llmClient.complete(prompt)\n    return extractCodeFromResponse(response)\n}\n\ndata class ExecutionContext(\n    val issueNumber: Int?,\n    val branchName: String?,\n    val createdFiles: MutableList<String>,\n    val modifiedFiles: MutableList<String>\n)\n```\n\n## Validation\n\n- Code generation uses LLM with proper context\n- Files are written correctly\n- Failures are categorized as recoverable/non-recoverable\n- Context accumulates created files for subsequent steps\n- Events track progress through execution",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-5"]
        },
        {
            "localId": "code-agent-loop-task-7",
            "type": "Task",
            "title": "AMP-305.7: Implement PR Creation and Review Request",
            "body": "## Context\n\nAfter code is committed and pushed, the agent needs to create a pull request and request review. This integrates with the QA agent or human reviewers.\n\n## Objective\n\nImplement PR creation with proper formatting and review request workflow.\n\n## Implementation Details\n\n```kotlin\n// Add to CodeWriterAgent\n\nprivate suspend fun createPullRequest(\n    issue: ExistingIssue,\n    branchName: String,\n    codeChanges: List<CodeChange>\n): Result<CreatedPullRequest> {\n    val prRequest = PullRequestCreateRequest(\n        title = generatePRTitle(issue),\n        body = generatePRBody(issue, codeChanges),\n        baseBranch = \"main\",\n        headBranch = branchName,\n        issueNumber = issue.number,\n        reviewers = determineReviewers(codeChanges),\n        labels = determinePRLabels(codeChanges),\n        draft = shouldCreateAsDraft(codeChanges)\n    )\n    \n    val result = gitExecutor.execute(\n        ExecutionRequest(\n            tool = ToolCreatePullRequest(prRequest),\n            agentId = id\n        )\n    )\n    \n    return when (result) {\n        is ExecutionOutcome.Success -> {\n            val pr = result.result as CreatedPullRequest\n            \n            // Notify reviewers\n            notifyReviewers(pr, prRequest.reviewers)\n            \n            // Update issue with PR link\n            linkPRToIssue(issue.number, pr.number)\n            \n            Result.success(pr)\n        }\n        is ExecutionOutcome.Failure -> {\n            Result.failure(Exception(result.error))\n        }\n        else -> Result.failure(Exception(\"Unexpected outcome\"))\n    }\n}\n\nprivate fun generatePRTitle(issue: ExistingIssue): String {\n    // Follow conventional format\n    val type = detectChangeType(issue)\n    return \"$type: ${issue.title}\"\n}\n\nprivate fun generatePRBody(issue: ExistingIssue, changes: List<CodeChange>): String {\n    return buildString {\n        appendLine(\"## Summary\")\n        appendLine()\n        appendLine(\"This PR implements #${issue.number}.\")\n        appendLine()\n        \n        appendLine(\"## Changes\")\n        appendLine()\n        changes.forEach { change ->\n            val icon = when (change.operation) {\n                FileOperation.CREATE -> \"‚ûï\"\n                FileOperation.MODIFY -> \"‚úèÔ∏è\"\n                FileOperation.DELETE -> \"üóëÔ∏è\"\n            }\n            appendLine(\"- $icon `${change.filePath}`: ${change.description}\")\n        }\n        appendLine()\n        \n        appendLine(\"## Testing\")\n        appendLine()\n        val testChanges = changes.filter { it.filePath.contains(\"test\", ignoreCase = true) }\n        if (testChanges.isNotEmpty()) {\n            appendLine(\"Added/updated tests:\")\n            testChanges.forEach { appendLine(\"- `${it.filePath}`\") }\n        } else {\n            appendLine(\"‚ö†Ô∏è No test changes in this PR. Consider adding tests.\")\n        }\n        appendLine()\n        \n        appendLine(\"## Checklist\")\n        appendLine()\n        appendLine(\"- [x] Code follows project conventions\")\n        appendLine(\"- [x] Changes are properly scoped to issue\")\n        appendLine(\"- [ ] Tests pass locally\")\n        appendLine(\"- [ ] Documentation updated if needed\")\n        appendLine()\n        \n        appendLine(\"---\")\n        appendLine(\"Closes #${issue.number}\")\n        appendLine()\n        appendLine(\"*This PR was created by CodeWriterAgent*\")\n    }\n}\n\nprivate fun determineReviewers(changes: List<CodeChange>): List<String> {\n    // Always include QA agent\n    val reviewers = mutableListOf(\"QualityAssuranceAgent\")\n    \n    // Add human reviewer for sensitive changes\n    if (changes.any { isSensitiveFile(it.filePath) }) {\n        reviewers.add(\"@wow-miley\") // Human fallback\n    }\n    \n    return reviewers\n}\n\nprivate fun isSensitiveFile(path: String): Boolean {\n    return path.contains(\"security\", ignoreCase = true) ||\n           path.contains(\"auth\", ignoreCase = true) ||\n           path.contains(\"secret\", ignoreCase = true) ||\n           path.endsWith(\".gradle.kts\") ||\n           path == \"build.gradle.kts\"\n}\n\nprivate suspend fun notifyReviewers(pr: CreatedPullRequest, reviewers: List<String>) {\n    reviewers.forEach { reviewer ->\n        eventBus.publish(ReviewRequestedEvent(\n            prNumber = pr.number,\n            prUrl = pr.url,\n            requestedBy = id,\n            requestedReviewer = AgentId(reviewer),\n            timestamp = Clock.System.now()\n        ))\n    }\n}\n\nprivate suspend fun linkPRToIssue(issueNumber: Int, prNumber: Int) {\n    issueExecutor.execute(\n        ExecutionRequest(\n            tool = ToolUpdateIssue(UpdateIssueRequest(\n                issueNumber = issueNumber,\n                addComment = \"üîó Pull request created: #$prNumber\"\n            )),\n            agentId = id\n        )\n    )\n}\n```\n\n## Validation\n\n- PR title follows conventional format\n- PR body includes summary, changes list, testing notes, checklist\n- PR body includes \"Closes #N\" for auto-linking\n- QA agent is always added as reviewer\n- Sensitive file changes add human reviewer\n- ReviewRequestedEvent is emitted\n- Issue is updated with PR link comment",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-6"]
        },
        {
            "localId": "code-agent-loop-task-8",
            "type": "Task",
            "title": "AMP-305.8: Add Issue Status Updates Throughout Workflow",
            "body": "## Context\n\nAs the agent works through an issue, the issue status should reflect current progress. This provides visibility to PM agent and humans.\n\n## Objective\n\nUpdate issue status/labels at each workflow stage: Assigned ‚Üí In Progress ‚Üí In Review ‚Üí Done.\n\n## Implementation Details\n\n```kotlin\n// Add to CodeWriterAgent\n\nenum class IssueWorkflowStatus(\n    val addLabels: List<String>,\n    val removeLabels: List<String>\n) {\n    CLAIMED(\n        addLabels = listOf(\"assigned\"),\n        removeLabels = listOf(\"available\", \"help-wanted\")\n    ),\n    IN_PROGRESS(\n        addLabels = listOf(\"in-progress\"),\n        removeLabels = listOf(\"assigned\", \"blocked\")\n    ),\n    BLOCKED(\n        addLabels = listOf(\"blocked\"),\n        removeLabels = listOf(\"in-progress\")\n    ),\n    IN_REVIEW(\n        addLabels = listOf(\"in-review\"),\n        removeLabels = listOf(\"in-progress\", \"blocked\")\n    ),\n    CHANGES_REQUESTED(\n        addLabels = listOf(\"changes-requested\"),\n        removeLabels = listOf(\"in-review\")\n    ),\n    APPROVED(\n        addLabels = listOf(\"approved\"),\n        removeLabels = listOf(\"in-review\", \"changes-requested\")\n    )\n    // DONE is handled by PR merge closing the issue\n}\n\nsuspend fun updateIssueStatus(\n    issueNumber: Int,\n    status: IssueWorkflowStatus,\n    comment: String? = null\n) {\n    val request = UpdateIssueRequest(\n        issueNumber = issueNumber,\n        addLabels = status.addLabels,\n        removeLabels = status.removeLabels,\n        addComment = comment\n    )\n    \n    issueExecutor.execute(\n        ExecutionRequest(\n            tool = ToolUpdateIssue(request),\n            agentId = id\n        )\n    )\n    \n    eventBus.publish(IssueStatusUpdatedEvent(\n        issueNumber = issueNumber,\n        newStatus = status.name,\n        updatedBy = id,\n        timestamp = Clock.System.now()\n    ))\n}\n\n// Integrate into workflow\n\nprivate suspend fun executeImplementationWorkflow(issue: ExistingIssue): Outcome {\n    try {\n        // 1. Mark as in progress\n        updateIssueStatus(\n            issue.number,\n            IssueWorkflowStatus.IN_PROGRESS,\n            \"ü§ñ CodeWriterAgent starting work on this issue\"\n        )\n        \n        // 2. Create branch, implement, commit, push...\n        val plan = determinePlanForTask(Task.fromIssue(issue))\n        val outcome = executePlan(plan)\n        \n        if (!outcome.success) {\n            // Mark as blocked if we failed\n            updateIssueStatus(\n                issue.number,\n                IssueWorkflowStatus.BLOCKED,\n                \"‚ö†Ô∏è Implementation hit a blocker: ${outcome.summary}\"\n            )\n            return outcome\n        }\n        \n        // 3. Create PR\n        val pr = createPullRequest(\n            issue = issue,\n            branchName = plan.metadata[\"branchName\"] as String,\n            codeChanges = extractCodeChanges(outcome)\n        ).getOrThrow()\n        \n        // 4. Mark as in review\n        updateIssueStatus(\n            issue.number,\n            IssueWorkflowStatus.IN_REVIEW,\n            \"üìù Pull request created: #${pr.number}\\nAwaiting review.\"\n        )\n        \n        return outcome.copy(\n            metadata = outcome.metadata + mapOf(\"prNumber\" to pr.number)\n        )\n        \n    } catch (e: Exception) {\n        updateIssueStatus(\n            issue.number,\n            IssueWorkflowStatus.BLOCKED,\n            \"‚ùå Error during implementation: ${e.message}\"\n        )\n        throw e\n    }\n}\n\n// Handle review feedback\n\nsuspend fun handleReviewFeedback(prNumber: Int, approved: Boolean, comments: List<String>) {\n    val issue = findIssueForPR(prNumber) ?: return\n    \n    if (approved) {\n        updateIssueStatus(\n            issue.number,\n            IssueWorkflowStatus.APPROVED,\n            \"‚úÖ PR approved! Ready for merge.\"\n        )\n    } else {\n        updateIssueStatus(\n            issue.number,\n            IssueWorkflowStatus.CHANGES_REQUESTED,\n            \"üîÑ Changes requested:\\n${comments.joinToString(\"\\n\") { \"- $it\" }}\"\n        )\n        \n        // Create task to address feedback\n        val feedbackTask = Task(\n            type = TaskType.ADDRESS_PR_FEEDBACK,\n            description = \"Address review feedback on PR #$prNumber\",\n            metadata = mapOf(\n                \"prNumber\" to prNumber,\n                \"issueNumber\" to issue.number,\n                \"comments\" to comments\n            )\n        )\n        \n        // Re-enter cognitive loop\n        val plan = determinePlanForTask(feedbackTask)\n        executePlan(plan)\n    }\n}\n```\n\n## Validation\n\n- Issue labels update at each stage\n- Comments provide human-readable progress updates\n- Blocked status is set on failures\n- In-review status is set after PR creation\n- Review feedback triggers appropriate status updates\n- Events are emitted for all status changes",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-7"]
        },
        {
            "localId": "code-agent-loop-task-9",
            "type": "Task",
            "title": "AMP-305.9: Integration Tests - Full Issue-to-PR Pipeline",
            "body": "## Context\n\nAll components need to work together for the full autonomous loop. This task validates end-to-end functionality.\n\n## Objective\n\nCreate integration tests validating the complete issue ‚Üí branch ‚Üí code ‚Üí commit ‚Üí push ‚Üí PR ‚Üí review workflow.\n\n## Implementation Details\n\n### Test Scenarios\n\n```kotlin\nclass CodeWriterAgentIntegrationTest {\n    \n    @Test\n    fun `agent discovers and claims unassigned issue`() = runTest {\n        // Setup: Create unassigned issue with 'code' label\n        val issue = createTestIssue(\n            title = \"Add greeting function\",\n            labels = listOf(\"task\", \"code\")\n        )\n        \n        // Execute: Agent perceives state\n        val perception = codeAgent.perceiveState()\n        \n        // Verify: Issue appears in availableIssues\n        assertTrue(perception.content.contains(issue.title))\n    }\n    \n    @Test\n    fun `agent creates branch for assigned issue`() = runTest {\n        // Setup\n        val issue = createTestIssue(\n            title = \"Implement helper utility\",\n            assignee = \"CodeWriterAgent\"\n        )\n        \n        // Execute\n        val task = Task.fromIssue(issue)\n        val plan = codeAgent.determinePlanForTask(task)\n        \n        // Verify: Plan includes branch creation step\n        val branchStep = plan.steps.find { it.tool is ToolCreateBranch }\n        assertNotNull(branchStep)\n        \n        val branchTool = branchStep.tool as ToolCreateBranch\n        assertTrue(branchTool.request.branchName.startsWith(\"feature/\"))\n        assertTrue(branchTool.request.branchName.contains(issue.number.toString()))\n    }\n    \n    @Test\n    fun `agent completes full implementation workflow`() = runTest {\n        // Setup: Real issue in test repo\n        val issue = createTestIssue(\n            title = \"Add fibonacci function\",\n            body = \"Create a function that returns the nth fibonacci number\",\n            assignee = \"CodeWriterAgent\"\n        )\n        \n        // Execute full workflow\n        val perception = codeAgent.perceiveState()\n        val task = Task.fromIssue(issue)\n        val plan = codeAgent.determinePlanForTask(task, perception)\n        val outcome = codeAgent.executePlan(plan)\n        \n        // Verify: Success\n        assertTrue(outcome.success)\n        \n        // Verify: Branch was created\n        val branches = gitProvider.listBranches()\n        assertTrue(branches.any { it.contains(issue.number.toString()) })\n        \n        // Verify: PR was created\n        val prNumber = outcome.metadata[\"prNumber\"] as Int\n        val pr = ghProvider.getPullRequest(prNumber)\n        assertNotNull(pr)\n        assertEquals(\"Closes #${issue.number}\", pr.body.substringAfterLast(\"---\").trim())\n        \n        // Verify: Issue status updated\n        val updatedIssue = ghProvider.getIssue(issue.number)\n        assertTrue(updatedIssue.labels.contains(\"in-review\"))\n        \n        // Verify: Events were emitted\n        val events = eventBus.allEvents()\n        assertTrue(events.any { it is GitBranchCreatedEvent })\n        assertTrue(events.any { it is GitCommittedEvent })\n        assertTrue(events.any { it is PullRequestCreatedEvent })\n        assertTrue(events.any { it is IssueStatusUpdatedEvent })\n    }\n    \n    @Test\n    fun `agent handles implementation failure gracefully`() = runTest {\n        // Setup: Issue with impossible requirements\n        val issue = createTestIssue(\n            title = \"Implement perpetual motion machine\",\n            body = \"Create code that violates thermodynamics\",\n            assignee = \"CodeWriterAgent\"\n        )\n        \n        // Execute\n        val task = Task.fromIssue(issue)\n        val plan = codeAgent.determinePlanForTask(task)\n        val outcome = codeAgent.executePlan(plan)\n        \n        // Verify: Graceful failure\n        assertFalse(outcome.success)\n        assertTrue(outcome.requiresHumanIntervention)\n        \n        // Verify: Issue marked as blocked\n        val updatedIssue = ghProvider.getIssue(issue.number)\n        assertTrue(updatedIssue.labels.contains(\"blocked\"))\n    }\n    \n    @Test\n    fun `agent addresses PR review feedback`() = runTest {\n        // Setup: Existing PR with changes requested\n        val issue = createTestIssue(assignee = \"CodeWriterAgent\")\n        val pr = createTestPR(issue)\n        requestChanges(pr, listOf(\"Add error handling\", \"Add tests\"))\n        \n        // Execute\n        codeAgent.handleReviewFeedback(\n            prNumber = pr.number,\n            approved = false,\n            comments = listOf(\"Add error handling\", \"Add tests\")\n        )\n        \n        // Verify: Issue status updated\n        val updatedIssue = ghProvider.getIssue(issue.number)\n        assertTrue(updatedIssue.labels.contains(\"changes-requested\"))\n        \n        // Verify: New commits address feedback\n        val commits = ghProvider.getPRCommits(pr.number)\n        assertTrue(commits.size > 1)\n    }\n}\n```\n\n### CLI Verification Command\n\nAdd command to trigger agent work loop:\n\n```kotlin\nclass AgentWorkCommand : CliktCommand(name = \"work\", help = \"Start agent work loop\") {\n    \n    private val agent by option(\"--agent\", \"-a\", help = \"Agent to activate\")\n        .default(\"CodeWriterAgent\")\n    \n    private val once by option(\"--once\", help = \"Run single work cycle\")\n        .flag(default = false)\n    \n    override fun run() = runBlocking {\n        val agent = container.get<CodeWriterAgent>()\n        \n        if (once) {\n            echo(\"Running single work cycle...\")\n            val result = agent.runWorkCycle()\n            echo(\"Result: ${result.summary}\")\n        } else {\n            echo(\"Starting continuous work loop (Ctrl+C to stop)...\")\n            agent.startWorkLoop()\n        }\n    }\n}\n```\n\n## Success Criteria\n\nComplete end-to-end test:\n\n1. Create issue: \"Add a StringUtils.kt file with a capitalize function\"\n2. Run: `ampere agent work --agent CodeWriterAgent --once`\n3. Observe:\n   - Issue status ‚Üí \"in-progress\"\n   - Branch created: `feature/123-add-stringutils-capitalize`\n   - File created: `StringUtils.kt`\n   - Commit: `feat(utils): add stringutils capitalize function`\n   - PR created with proper body\n   - Issue status ‚Üí \"in-review\"\n   - QA agent notified\n4. Verify code compiles: `./gradlew build`\n5. Merge PR\n6. Issue auto-closes\n\nThis completes the autocatalytic loop.",
            "labels": ["task"],
            "parent": "code-agent-loop-epic",
            "dependsOn": ["code-agent-loop-task-6", "code-agent-loop-task-7", "code-agent-loop-task-8"]
        }
    ]
}
