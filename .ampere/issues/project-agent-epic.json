{
  "repository": "socket-link/ampere",
  "issues": [
    {
      "localId": "pm-agent-epic",
      "type": "Feature",
      "title": "Implement ProjectManagerAgent",
      "body": "## Context\n\nAMPERE's multi-agent architecture envisions specialized agents coordinating to accomplish complex goals. `CodeWriterAgent` handles code generation and file manipulation. `QualityAssuranceAgent` validates outputs. But there's a critical gap: **no agent is responsible for work decomposition, prioritization, and coordination**.\n\nIn a human organization, the Product/Project Manager translates high-level goals into actionable work items, assigns work to the right people, tracks progress, and unblocks the team when dependencies stall. This is the missing \"prefrontal cortex\" of the AMPERE nervous system—the planning and coordination center that transforms vague intentions into structured execution.\n\nThe `ProjectManagerAgent` fills this role. It receives goals (from humans or other agents), breaks them into epics and tasks, creates issues in external systems (using `ToolCreateIssues`), assigns work to appropriate agents, monitors progress through the event stream, and escalates when human decisions are needed.\n\nBiologically, this agent acts as the **executive function**—maintaining working memory of project state, inhibiting premature action (ensuring dependencies are satisfied before work begins), and flexibly switching between planning and monitoring modes based on system state.\n\n## Objective\n\nImplement `ProjectManagerAgent` as a fully autonomous agent capable of:\n1. Decomposing high-level goals into structured work breakdowns\n2. Creating issues in external systems via `ToolCreateIssues`\n3. Assigning tasks to appropriate agents based on capabilities\n4. Monitoring task progress and adjusting plans\n5. Facilitating coordination when agents are blocked\n6. Escalating to humans when decisions exceed agent authority\n\n## Expected Outcomes\n\n- `ProjectManagerAgent` can receive a goal like \"Implement MCP server integration\" and autonomously create a structured epic with tasks\n- Tasks are assigned to `CodeWriterAgent` or other appropriate agents\n- PM monitors the event stream and detects when tasks complete or stall\n- PM initiates meetings when coordination is needed\n- PM updates issue status as work progresses\n- PM escalates to humans for scope decisions, priority conflicts, or unclear requirements\n- Full observability: PM's planning and coordination activities visible in CLI\n\n## Technical Constraints\n\n- Extend `AutonomousAgent` base class following established patterns\n- Implement all five PROPEL cognitive functions\n- Use existing tool infrastructure (`ToolCreateIssues`, `ToolQueryIssues`, `AskHumanTool`)\n- Emit events for all state changes (planning started, task assigned, etc.)\n- Store learnings in Knowledge system for improved future planning\n- Integrate with Meeting system for multi-agent coordination\n\n## Subtasks\n\n1. AMP-303.1: Create ProjectManagerAgent Scaffold\n2. AMP-303.2: Implement Goal Decomposition Prompts\n3. AMP-303.3: Implement perceiveState for Project Context\n4. AMP-303.4: Implement determinePlanForTask for Work Breakdown\n5. AMP-303.5: Implement executePlan with Issue and Assignment Tools\n6. AMP-303.6: Implement Progress Monitoring and Blocker Detection\n7. AMP-303.7: Implement Human Escalation Patterns\n8. AMP-303.8: Integration Tests and End-to-End Validation",
      "labels": ["feature"],
      "parent": null,
      "dependsOn": []
    },
    {
      "localId": "pm-agent-task-1",
      "type": "Task",
      "title": "AMP-303.1: Create ProjectManagerAgent Scaffold",
      "body": "## Context\n\nBefore implementing cognitive functions, we need the basic agent structure following patterns established by `CodeWriterAgent`.\n\n## Objective\n\nCreate the `ProjectManagerAgent` class extending `AutonomousAgent` with appropriate configuration, tool list, and system prompt foundation.\n\n## Implementation Details\n\n**File: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/implementations/pm/ProjectManagerAgent.kt`**\n\nCreate class with:\n- `id: AgentId = AgentId(\"ProjectManagerAgent\")`\n- Tools: `ToolCreateIssues`, `ToolQueryIssues`, `ToolUpdateIssue`, `AskHumanTool`\n- Personality: directness=0.8, creativity=0.5, verbosity=0.6, formality=0.7\n- System prompt defining PM role, capabilities, work breakdown structure guidelines, and decision authority boundaries\n- Stub implementations for all five PROPEL cognitive functions\n\nThe system prompt should define:\n- PM's role (decompose goals, create issues, assign work, monitor progress, coordinate, escalate)\n- Available capabilities (issue CRUD, agent assignment, meetings, human escalation)\n- Work breakdown structure guidelines (one Feature epic, multiple Task issues, clear dependencies)\n- Decision authority (what PM can decide vs must escalate)\n\n## Validation\n\n- Class compiles and extends AutonomousAgent correctly\n- Tool list includes issue management tools\n- System prompt provides clear guidance\n- Agent can be instantiated in test",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": []
    },
    {
      "localId": "pm-agent-task-2",
      "type": "Task",
      "title": "AMP-303.2: Implement Goal Decomposition Prompts",
      "body": "## Context\n\nThe PM agent needs sophisticated prompts for breaking down goals into structured work. This is the \"thinking\" template that guides the LLM to produce well-structured work breakdowns.\n\n## Objective\n\nCreate prompt templates that guide the LLM to decompose goals into epics, tasks, dependencies, and validation criteria—outputting JSON that matches `BatchIssueCreateRequest`.\n\n## Implementation Details\n\n**File: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/implementations/pm/PMPrompts.kt`**\n\nCreate `PMPrompts` object with:\n\n1. `goalDecompositionPrompt(goal, repository, availableAgents, existingIssues)` - Takes a goal and context, outputs JSON matching BatchIssueCreateRequest schema. Includes guidelines for epic structure, task granularity, dependency identification, and duplicate avoidance.\n\n2. `taskAssignmentPrompt(task, availableAgents)` - Selects appropriate agent based on capability match, current workload, and past performance. Outputs JSON with assignedAgent and reasoning.\n\n3. `progressAssessmentPrompt(epic, tasks, recentEvents)` - Assesses progress percentage, identifies blocked tasks, surfaces risks, recommends next actions, flags if human input needed.\n\nAlso create `AgentCapability` data class with agentId, capabilities list, and currentTaskCount.\n\n## Validation\n\n- Goal decomposition prompt produces valid JSON\n- Task assignment prompt selects appropriate agents\n- Progress assessment identifies blockers correctly\n- Prompts handle edge cases (no existing issues, single agent, etc.)",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-1"]
    },
    {
      "localId": "pm-agent-task-3",
      "type": "Task",
      "title": "AMP-303.3: Implement perceiveState for Project Context",
      "body": "## Context\n\nThe PM agent needs to understand the current state of projects, agents, and work items to make informed decisions. `perceiveState` gathers this context from multiple sources.\n\n## Objective\n\nImplement `perceiveState` to gather project context including active goals, issue states, agent availability, and recent events.\n\n## Implementation Details\n\nThe perceiveState implementation should:\n\n1. Query existing issues from GitHub via `ToolQueryIssues`\n2. Get current agent states from event bus\n3. Get recent significant events (filter out routine cognitive events)\n4. Recall relevant knowledge from memory\n5. Identify pending human responses/escalations\n6. Synthesize into a `Perception` data class containing:\n   - currentGoals\n   - projectState (open issue count, etc.)\n   - agentAvailability\n   - blockers\n   - pendingDecisions\n   - timestamp\n7. Run LLM via `runLLMToEvaluatePerception` to synthesize perception with new ideas into actionable insight\n\nHelper methods needed:\n- `gatherAgentStates()` - collect agent states from event bus\n- `findPendingEscalations()` - identify unanswered human queries\n- `extractActiveGoals(issues)` - find open epics/features\n- `assessProjectState(issues)` - calculate metrics\n- `identifyBlockers(issues, events)` - find stalled work\n\n## Validation\n\n- perceiveState queries GitHub for open issues\n- Agent states are gathered from event bus\n- Blockers are identified from stalled tasks\n- LLM synthesizes perception into actionable insight",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-1"]
    },
    {
      "localId": "pm-agent-task-4",
      "type": "Task",
      "title": "AMP-303.4: Implement determinePlanForTask for Work Breakdown",
      "body": "## Context\n\nWhen the PM receives a goal, it needs to create a plan that includes issue creation, task assignment, and monitoring steps. This is where goals become structured work.\n\n## Objective\n\nImplement `determinePlanForTask` to generate work breakdown plans using the goal decomposition prompts.\n\n## Implementation Details\n\nThe implementation should:\n\n1. Determine task type - is this a new goal (GOAL_DECOMPOSITION) or existing work?\n\n2. For new goals (`createGoalDecompositionPlan`):\n   - Gather context (existing issues, available agents)\n   - Generate work breakdown via LLM using `PMPrompts.goalDecompositionPrompt`\n   - Parse response as `BatchIssueCreateRequest`\n   - Generate assignment decisions for each task using `PMPrompts.taskAssignmentPrompt`\n   - Build plan steps:\n     - Step 1: Create issues via `ToolCreateIssues`\n     - Step 2+: Assign tasks to agents via `AssignTaskAction`\n     - Final step: Start monitoring via `StartMonitoringAction`\n\n3. For existing work (`createProgressMonitoringPlan`):\n   - Query current state\n   - Identify next actions needed\n   - Build appropriate plan steps\n\nCreate action types:\n- `AssignTaskAction(taskLocalId, agentId)`\n- `StartMonitoringAction(epicLocalId)`\n\n## Validation\n\n- Goal decomposition produces valid `BatchIssueCreateRequest`\n- Each task gets an assignment decision\n- Plan includes create, assign, and monitor steps\n- Invalid LLM output is handled gracefully",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-2", "pm-agent-task-3"]
    },
    {
      "localId": "pm-agent-task-5",
      "type": "Task",
      "title": "AMP-303.5: Implement executePlan with Issue and Assignment Tools",
      "body": "## Context\n\nOnce the PM has a plan, it needs to execute it—creating issues, assigning tasks, and initiating monitoring. This connects planning to action.\n\n## Objective\n\nImplement `executePlan` to carry out work breakdown plans, handling issue creation and task assignment.\n\n## Implementation Details\n\nThe executePlan implementation should:\n\n1. Iterate through plan steps, tracking:\n   - `stepOutcomes: MutableList<StepOutcome>`\n   - `createdIssueMap: MutableMap<String, Int>` (localId → issueNumber)\n\n2. For each step:\n   - Emit `PlanStepStartedEvent`\n   - Execute based on step type (tool or action)\n   - Record outcome\n   - Emit `PlanStepCompletedEvent`\n   - Stop on critical failure\n\n3. `executeToolStep` handling:\n   - For `ToolCreateIssues`: invoke executor, store localId→issueNumber mappings from response\n   - Handle Success, PartialSuccess, Failure outcomes appropriately\n\n4. `executeActionStep` handling:\n   - For `AssignTaskAction`: resolve issueNumber from map, emit `TaskAssignedEvent`\n   - For `StartMonitoringAction`: register epic for progress tracking\n\n5. Return `Outcome` with all step outcomes, overall success, and summary\n\nCreate `StepOutcome` sealed class with Success, PartialSuccess, Failure, Skipped variants.\n\n## Validation\n\n- Issue creation tool is invoked correctly\n- Created issue numbers are stored for subsequent steps\n- Task assignment events are emitted\n- Partial failures don't stop entire plan\n- Critical failures halt execution",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-4"]
    },
    {
      "localId": "pm-agent-task-6",
      "type": "Task",
      "title": "AMP-303.6: Implement Progress Monitoring and Blocker Detection",
      "body": "## Context\n\nAfter creating work, the PM needs to monitor progress, detect when tasks are blocked, and take corrective action. This is the ongoing coordination role.\n\n## Objective\n\nImplement progress monitoring that detects stalled tasks, identifies blockers, and initiates coordination when needed.\n\n## Implementation Details\n\nAdd to ProjectManagerAgent:\n\n1. State tracking:\n   - `monitoredEpics: MutableSet<Int>`\n   - `taskLastActivity: MutableMap<Int, Instant>`\n   - `stallThreshold = 30.minutes`\n\n2. `startMonitoring(epicIssueNumber)` - register epic for tracking\n\n3. `checkProgress(): List<ProgressAlert>` - called periodically:\n   - Query current epic and task states\n   - Check for stalled tasks (no activity > threshold)\n   - Check for blocking dependencies (open deps blocking open tasks)\n   - Calculate progress percentage\n   - Return alerts for issues found\n\n4. `handleAlerts(alerts)` - react to problems:\n   - TaskStalled → emit `CoordinationRequestEvent` to assigned agent\n   - BlockedByDependency → emit `BlockerIdentifiedEvent`\n   - BehindSchedule → escalate to human if significantly behind (>20%)\n\n5. Create `ProgressAlert` sealed class:\n   - `TaskStalled(issueNumber, title, stalledFor)`\n   - `BlockedByDependency(issueNumber, blockedBy: List<Int>)`\n   - `BehindSchedule(epicNumber, expectedPercent, actualPercent)`\n\nHelper methods:\n- `extractDependencies(issueBody)` - parse \"Depends on #N\" from body\n- `expectedProgress(createdAt)` - calculate expected % based on elapsed time\n- `getAssignedAgent(issueNumber)` - find who owns a task\n\n## Validation\n\n- Stalled tasks are detected after threshold\n- Dependency blockers are identified\n- Progress percentage is calculated correctly\n- Appropriate events are emitted for each alert type\n- Significant delays trigger human escalation",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-5"]
    },
    {
      "localId": "pm-agent-task-7",
      "type": "Task",
      "title": "AMP-303.7: Implement Human Escalation Patterns",
      "body": "## Context\n\nThe PM must know when to escalate decisions to humans. This prevents the agent from making decisions beyond its authority while ensuring humans are only bothered for genuinely important matters.\n\n## Objective\n\nImplement escalation patterns that identify when human input is needed and use `AskHumanTool` appropriately.\n\n## Implementation Details\n\n1. Create `EscalationReason` enum:\n   - SCOPE_CHANGE, PRIORITY_CONFLICT, UNCLEAR_REQUIREMENTS\n   - RESOURCE_CONSTRAINT, SIGNIFICANT_DELAY, AGENT_DISAGREEMENT\n   - HIGH_RISK_DECISION, EXTERNAL_DEPENDENCY\n\n2. Create `EscalationContext` data class:\n   - reason: EscalationReason\n   - summary: String\n   - options: List<String>? (if presenting choices)\n   - deadline: Instant? (if time-sensitive)\n   - relatedIssues: List<Int>\n\n3. `escalateToHuman(context): HumanResponse`:\n   - Build escalation message with reason, summary, options, deadline, related issues\n   - Emit `HumanEscalationRequestedEvent`\n   - Invoke `AskHumanTool` with appropriate urgency\n   - Emit `HumanResponseReceivedEvent` on response\n   - Return `HumanResponse` (Received/Timeout/Declined)\n\n4. `shouldEscalate(situation): EscalationContext?` - decision logic:\n   - Scope changes → always escalate with approve/reject/discuss options\n   - High ambiguity (score > 0.7) → escalate for clarification\n   - Significant delay (>20%) → escalate with timeline options\n   - Otherwise → return null (no escalation needed)\n\n5. `buildEscalationMessage(context)` - format clear, actionable message\n\n6. Create `HumanResponse` sealed class: Received(response), Timeout, Declined\n\n## Validation\n\n- Scope changes trigger escalation\n- Unclear requirements trigger clarification requests\n- Significant delays are surfaced to humans\n- Escalation messages are clear and actionable\n- Human responses are processed correctly",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-5", "pm-agent-task-6"]
    },
    {
      "localId": "pm-agent-task-8",
      "type": "Task",
      "title": "AMP-303.8: Integration Tests and End-to-End Validation",
      "body": "## Context\n\nAll PM components need to work together. This task validates the full flow from goal → work breakdown → issue creation → assignment → monitoring.\n\n## Objective\n\nCreate integration tests that validate end-to-end PM functionality and complete the `evaluateNextIdeaFromOutcomes` implementation.\n\n## Implementation Details\n\n### Complete evaluateNextIdeaFromOutcomes\n\nImplement to:\n1. Analyze outcomes (count successes/failures)\n2. Extract learnings as Knowledge items (SUCCESS_PATTERN or FAILURE_PATTERN)\n3. Store learnings via storeKnowledge\n4. Generate next idea via LLM based on outcomes\n5. Return Idea with EVALUATION source and confidence based on outcome success rate\n\n### Integration Tests\n\n1. `PM decomposes goal into issues and assigns work`:\n   - Create PM with real dependencies\n   - Execute full PROPEL cycle: perceiveState → determinePlanForTask → executePlan → evaluateNextIdeaFromOutcomes\n   - Verify issues created with proper hierarchy\n   - Verify TaskAssignedEvents emitted\n   - Verify next idea suggests monitoring\n\n2. `PM detects stalled task and initiates coordination`:\n   - Setup PM monitoring an epic\n   - Simulate stall (set taskLastActivity to 45min ago)\n   - Run checkProgress and handleAlerts\n   - Verify CoordinationRequestEvent emitted\n\n3. `PM escalates scope change to human`:\n   - Create situation with impliesScopeChange=true\n   - Verify shouldEscalate returns SCOPE_CHANGE context\n   - Mock human response\n   - Verify escalation flow completes\n\n### CLI Integration\n\nAdd `pm-status` command showing:\n- Monitored epics count\n- Active plans count\n- Per-epic status (on track / alerts)\n\n## Validation\n\n- Full cycle test passes: goal → issues → assignments → monitoring\n- Stalled task detection triggers coordination\n- Scope changes escalate to humans\n- CLI can display PM status\n\n## Success Criteria\n\nEnd-to-end scenario works:\n1. Human provides goal: \"Implement user authentication\"\n2. PM decomposes into epic + tasks\n3. PM creates GitHub issues\n4. PM assigns tasks to CodeWriterAgent\n5. PM monitors progress\n6. If CodeWriter stalls, PM initiates coordination\n7. If scope creeps, PM escalates to human\n8. All activity visible in CLI coordination view",
      "labels": ["task"],
      "parent": "pm-agent-epic",
      "dependsOn": ["pm-agent-task-5", "pm-agent-task-6", "pm-agent-task-7"]
    }
  ]
}
