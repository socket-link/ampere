{
    "repository": "socket-link/ampere",
    "issues": [
        {
            "localId": "cli-ux-polish-epic",
            "type": "Feature",
            "title": "CLI UX Polish for MVP Release",
            "body": "## Context\n\nThe AMPERE CLI serves as the primary window into the nervous system—the membrane through which humans observe agent cognition, monitor coordination, and intervene when needed. For the MVP release, the CLI must communicate **competence and intentionality**. Every visual element should reinforce that this is a coherent, well-designed system rather than a prototype held together with duct tape.\n\nCurrently, several UX issues undermine this impression:\n- **Visual artifacts**: Token counts leaking below the TUI, mysterious green rectangles, status desync\n- **Spatial disorientation**: Agent focus mode replaces the entire screen, breaking context\n- **Information density problems**: UUIDs consume space without adding value, events feel cramped, empty states feel hollow\n- **Inconsistent hierarchy**: Headers blend into content, the status bar is dense and undifferentiated\n\nThese issues aren't cosmetic—they're **cognitive load problems**. Every moment a user spends parsing cluttered output or reorienting after a mode switch is a moment they're not understanding what their agents are doing.\n\nBiologically, think of the CLI as the **sensory cortex**—it must present neural activity (events, state changes, cognitive cycles) in a form the conscious mind (human operator) can parse effortlessly. Visual noise is like sensory static; it degrades the signal-to-noise ratio of the entire system.\n\n## Objective\n\nDeliver a polished, coherent CLI experience for MVP that:\n1. Eliminates all visual bugs and rendering artifacts\n2. Maintains spatial context during mode transitions\n3. Presents information with clear visual hierarchy and appropriate density\n4. Handles empty/idle states gracefully\n5. Communicates system state accurately and immediately\n\n## Expected Outcomes\n\n- Zero visual artifacts or escaped output during normal operation\n- Agent focus mode feels like \"zooming in\" rather than \"teleporting away\"\n- Users can scan the interface and understand system state within 2 seconds\n- Empty states communicate useful information rather than hollow placeholders\n- Status bar accurately reflects system state at all times\n- UUIDs and timestamps are truncated/formatted for human consumption\n- Consistent spacing and visual rhythm throughout\n\n## Technical Constraints\n\n- All rendering through Mordant terminal library\n- ANSI escape sequences for styling (no Unicode emoji, single-width chars only)\n- 4 FPS refresh rate for TUI, 20 Hz for input polling\n- Alternate screen buffer for TUI modes\n- Must maintain column alignment across all terminal widths ≥80 chars\n- JLine for raw mode keyboard input\n\n## Subtasks\n\n1. AMP-401.1: Fix Token Count Leak Below TUI\n2. AMP-401.2: Investigate and Fix Green Rectangle Artifacts\n3. AMP-401.3: Sync Status Bar with Task Lifecycle\n4. AMP-401.4: Implement Agent Focus as Drawer Panel\n5. AMP-401.5: Add Section Header Separators and Spacing\n6. AMP-401.6: Implement UUID and ID Truncation\n7. AMP-401.7: Improve Event Stream Entry Formatting\n8. AMP-401.8: Refine Status Bar Layout and Shortcuts\n9. AMP-401.9: Enhance Right Pane Empty States\n10. AMP-401.10: Implement Cognitive Cycle Tree View",
            "labels": ["feature", "ux", "mvp"],
            "parent": null,
            "dependsOn": []
        },
        {
            "localId": "cli-token-leak-fix",
            "type": "Bug",
            "title": "Fix Token Count Leak Below TUI",
            "body": "## Context\n\nDuring CLI operation, token count information momentarily appears beneath the TUI boundary, then disappears. This indicates output is escaping the alternate screen buffer—likely a print statement, logger, or LLM response callback writing directly to `System.out` instead of routing through the TUI renderer.\n\nThis bug breaks the **membrane integrity** of the CLI. The alternate buffer exists to create a clean separation between TUI content and shell history. When content leaks through, it signals loss of control—exactly the opposite of what we want users to feel when observing autonomous agents.\n\n## Objective\n\nEnsure all output during TUI mode routes through the renderer. Nothing should appear outside the TUI frame.\n\n## Expected Outcomes\n\n- Run a complete Jazz Test cycle with no text appearing below the status bar\n- Run with `--verbose` flag with no leakage\n- Trigger error conditions (network timeout, invalid response) with no leakage\n- All LLM token/usage metrics either suppressed or displayed within TUI\n\n## Technical Approach\n\n### Step 1: Identify the Leak Source\n\n1. Search codebase for direct stdout writes:\n   ```bash\n   grep -r \"println\" --include=\"*.kt\" | grep -v \"//\"\n   grep -r \"System.out\" --include=\"*.kt\"\n   grep -r \"print(\" --include=\"*.kt\" | grep -v \"//\"\n   ```\n\n2. Check LLM client callbacks—token usage is often logged in response handlers:\n   - Look in `LlmClient.kt` or equivalent\n   - Check `ChatCompletion` response processing\n   - Look for usage/metrics logging\n\n3. Check logging configuration:\n   - Review `Logging.kt` or logback/log4j config\n   - Ensure console appenders are disabled during TUI mode\n\n### Step 2: Route Output Through TUI\n\n1. If token metrics are valuable, add them to the TUI:\n   - Option A: Add to status bar: `Status: WORKING │ 1.2k tokens`\n   - Option B: Add to agent panel when in focus mode\n   - Option C: Make available via `:tokens` command\n\n2. If token metrics should be suppressed:\n   - Add TUI mode flag that silences non-essential output\n   - Wrap print statements in `if (!tuiMode)` guards\n\n3. For any remaining loggers:\n   - Create `TuiAwareAppender` that buffers during TUI mode\n   - Or redirect to file during TUI operation\n\n### Step 3: Add Leak Detection\n\n1. In test mode, capture stdout and fail if anything writes outside render cycle:\n   ```kotlin\n   val stdout = System.out\n   val leakDetector = LeakDetectorOutputStream()\n   System.setOut(PrintStream(leakDetector))\n   // ... run TUI ...\n   assertThat(leakDetector.hasLeaks()).isFalse()\n   ```\n\n## Validation Criteria\n\n- [ ] `ampere test jazz` completes with zero output below status bar\n- [ ] `ampere test jazz --verbose` completes with zero leakage\n- [ ] Force an LLM timeout and verify error displays within TUI\n- [ ] Token metrics are either visible in TUI or completely suppressed\n- [ ] No regression in existing CLI functionality",
            "labels": ["bug", "cli", "p0"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": []
        },
        {
            "localId": "cli-green-rectangles-fix",
            "type": "Bug",
            "title": "Investigate and Fix Green Rectangle Artifacts",
            "body": "## Context\n\nThe Jazz Test display shows dark green rectangular areas in the middle and right panes that appear to be either:\n1. Failed image render placeholders\n2. Conditional render blocks that aren't being cleared\n3. ANSI escape sequence corruption leaving background colors set\n4. Debug/development placeholders that were never removed\n\nThese artifacts occupy significant screen real estate and make the interface look broken. They're particularly visible in the completed state where the cognitive cycle pane should show clean results.\n\n## Objective\n\nIdentify the source of green rectangle artifacts and eliminate them entirely.\n\n## Expected Outcomes\n\n- Jazz Test display shows clean, artifact-free rendering at all stages\n- No unexplained colored regions in any pane\n- Background colors only appear intentionally (e.g., progress bars, highlights)\n\n## Technical Approach\n\n### Step 1: Reproduce and Isolate\n\n1. Run `ampere test jazz` and screenshot at multiple stages:\n   - Initial state\n   - During PERCEIVE phase\n   - During EXECUTE phase\n   - Completed state\n   \n2. Note which stages show artifacts and whether they're consistent\n\n3. Check if artifacts appear in other modes:\n   - `ampere start` (dashboard mode)\n   - `ampere watch` (streaming mode)\n   - Different terminal emulators (iTerm2, Terminal.app, Alacritty)\n\n### Step 2: Search for Background Color Usage\n\n1. Find all background color applications:\n   ```bash\n   grep -r \"bgGreen\\|bg(\\|background\" --include=\"*.kt\" src/\n   grep -r \"\\\\u001B\\[4\" --include=\"*.kt\" src/  # ANSI bg codes\n   ```\n\n2. Look for conditional rendering that might not clear:\n   ```kotlin\n   // Pattern to find:\n   if (someCondition) {\n       render(greenBackground(content))\n   }\n   // Missing else branch that clears the region\n   ```\n\n3. Check for fixed-size placeholder logic:\n   ```kotlin\n   // Pattern to find:\n   val placeholder = \" \".repeat(width) // with background color?\n   ```\n\n### Step 3: Audit Render Functions\n\n1. Examine `JazzTestRenderer.kt` or equivalent:\n   - Find the middle pane render function\n   - Find the right pane render function\n   - Trace what gets rendered in each cell/region\n\n2. Check for incomplete clear operations:\n   ```kotlin\n   // Should be clearing entire region before re-render\n   clearRegion(x, y, width, height)\n   renderContent(x, y, content)\n   ```\n\n3. Look for background color leaks in string building:\n   ```kotlin\n   // Problem pattern:\n   val line = greenBg(\"Status\") + \" \" + content\n   // The space might carry the green background\n   ```\n\n### Step 4: Fix and Verify\n\n1. If placeholder boxes: Remove them or make them invisible\n2. If color leak: Ensure explicit color reset after every styled segment\n3. If clear issue: Add explicit region clearing before each render pass\n4. If conditional render: Add else branches that render empty/default state\n\n## Validation Criteria\n\n- [ ] `ampere test jazz` shows no green rectangles at any stage\n- [ ] Dashboard mode (`ampere start`) shows no artifacts\n- [ ] Verified in at least 2 different terminal emulators\n- [ ] No regression in intentional color usage (status indicators, progress bars)",
            "labels": ["bug", "cli", "p0"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": []
        },
        {
            "localId": "cli-status-sync-fix",
            "type": "Bug",
            "title": "Sync Status Bar with Task Lifecycle",
            "body": "## Context\n\nThe Jazz Test screenshot shows `[COMPLETED]` in the cognitive cycle pane while the status bar still displays `Status: WORKING`. This desync undermines user trust—if the UI can't accurately report whether work is done, how can users trust it to report anything else?\n\nThe status bar should be the **ground truth** for system state. It's the first place users look to understand what's happening. A stale status is worse than no status.\n\n## Objective\n\nEnsure the status bar reflects actual system state in real-time, with state transitions happening within one render frame (~250ms) of the underlying event.\n\n## Expected Outcomes\n\n- Status transitions from WORKING → COMPLETED within 250ms of task completion\n- Status shows IDLE when no tasks are active\n- Status shows THINKING during planning phases\n- Status shows WAITING when blocked on human input\n- Status shows ERROR when exceptions occur\n\n## Technical Approach\n\n### Step 1: Map Status States to Events\n\nDefine the canonical mapping:\n\n| Status | Trigger Event(s) |\n|--------|------------------|\n| IDLE | No active tasks, all agents idle |\n| THINKING | PlanningStarted, agent in planning phase |\n| WORKING | ExecutionStarted, agent actively executing |\n| WAITING | HumanInputRequested, blocked on AskHumanTool |\n| COMPLETED | All tasks in current batch completed |\n| ERROR | ExceptionOccurred, TaskFailed |\n\n### Step 2: Find Current Status Logic\n\n1. Locate status bar rendering:\n   ```bash\n   grep -r \"Status:\" --include=\"*.kt\" src/\n   grep -r \"statusBar\\|StatusBar\" --include=\"*.kt\" src/\n   ```\n\n2. Trace how status string is determined:\n   - Is it reading from a state variable?\n   - Is it computed from agent states?\n   - Is it event-driven or poll-based?\n\n3. Identify the staleness source:\n   - Missing event subscription?\n   - Event not being emitted?\n   - State variable not being updated?\n\n### Step 3: Implement Event-Driven Status\n\n1. If not already, create a `SystemStatus` sealed class:\n   ```kotlin\n   sealed class SystemStatus {\n       object Idle : SystemStatus()\n       object Thinking : SystemStatus()\n       object Working : SystemStatus()\n       object Waiting : SystemStatus()\n       data class Completed(val taskId: String) : SystemStatus()\n       data class Error(val message: String) : SystemStatus()\n   }\n   ```\n\n2. Create status reducer that listens to EventBus:\n   ```kotlin\n   class StatusTracker(private val eventBus: EventSerializerBus) {\n       private val _status = MutableStateFlow<SystemStatus>(SystemStatus.Idle)\n       val status: StateFlow<SystemStatus> = _status.asStateFlow()\n       \n       init {\n           eventBus.subscribe<TaskCompleted> { \n               if (noRemainingTasks()) _status.value = SystemStatus.Completed(it.taskId)\n           }\n           eventBus.subscribe<ExecutionStarted> {\n               _status.value = SystemStatus.Working\n           }\n           // ... other subscriptions\n       }\n   }\n   ```\n\n3. Wire status to renderer:\n   ```kotlin\n   fun renderStatusBar(status: SystemStatus): String {\n       val statusText = when (status) {\n           is SystemStatus.Idle -> dim(\"IDLE\")\n           is SystemStatus.Working -> yellow(\"WORKING\")\n           is SystemStatus.Completed -> green(\"COMPLETED\")\n           // ...\n       }\n       return \"Status: $statusText\"\n   }\n   ```\n\n### Step 4: Add Completion Detection for Jazz Test\n\n1. Jazz Test specifically needs to detect all-phases-complete:\n   ```kotlin\n   // In JazzTestController or equivalent\n   fun checkCompletion(): Boolean {\n       return cognitiveCycle.allPhasesComplete() && \n              currentTask?.status == TaskStatus.COMPLETED\n   }\n   ```\n\n2. Emit completion event when Jazz Test finishes:\n   ```kotlin\n   if (checkCompletion() && !completionEmitted) {\n       eventBus.emit(JazzTestCompleted(elapsed = timer.elapsed()))\n       completionEmitted = true\n   }\n   ```\n\n## Validation Criteria\n\n- [ ] Run Jazz Test and verify status shows COMPLETED when `[COMPLETED]` appears\n- [ ] Status shows WORKING during active execution\n- [ ] Status shows IDLE after returning to dashboard from completed test\n- [ ] Status updates within 250ms of state change (visually imperceptible delay)\n- [ ] Error states properly reflected in status bar",
            "labels": ["bug", "cli", "p0"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": []
        },
        {
            "localId": "cli-agent-focus-drawer",
            "type": "Task",
            "title": "Implement Agent Focus as Drawer Panel",
            "body": "## Context\n\nCurrently, pressing `1-9` to focus on an agent replaces the entire screen with agent details. This full-screen replacement causes **spatial disorientation**—users lose context about what else is happening in the system. It's like closing all your browser tabs to look at one page.\n\nThe nervous system metaphor suggests a better model: **attention as a spotlight, not a teleporter**. When you focus on a specific neuron's activity, you don't lose awareness of the broader neural context—you zoom in while maintaining peripheral vision.\n\nA drawer/panel pattern achieves this: the focused agent expands to occupy more space while the event stream compresses to a minimal summary column. The user can still see event numbers for quick switching, maintaining their mental model of system activity.\n\n## Objective\n\nReplace full-screen agent focus with an expanding drawer pattern that maintains context awareness.\n\n## Expected Outcomes\n\n- Pressing `a` then `1-9` expands right pane to ~60% width\n- Event stream compresses to ~15% showing only event numbers and icons\n- Middle pane compresses to ~25% showing minimal context\n- ESC returns smoothly to normal 35/40/25 layout\n- Transition feels like zooming, not teleporting\n- User can still press other number keys to switch focus without returning to normal mode\n\n## Visual Design\n\n### Normal Layout (35% / 40% / 25%)\n```\n┌─────────────────┬─────────────────────┬─────────────┐\n│ EVENT STREAM    │ THE JAZZ TEST       │ AGENT       │\n│                 │                     │             │\n│ 1. > MsgPosted  │ Elapsed: 27s        │ CodeWriter  │\n│    \"[e80c6ea3]\" │                     │   idle      │\n│    SYSTEM_ORCH  │ Ticket: ...4be2-b   │             │\n│                 │ Agent: CodeWriter   │ Phase:      │\n│ 2. + Assigned   │                     │ Completed   │\n│    Assigned to  │ Cognitive Cycle     │             │\n│    human-jazz   │ ✓ PERCEIVE Complete │ MEMORY      │\n│                 │ ✓ PLAN     Complete │ [----] 0%   │\n│ 3. + Created    │ ✓ EXECUTE  Complete │             │\n│    Ticket: Impl │ ✓ LEARN    Complete │ < 0         │\n│    human-jazz   │                     │ > 0         │\n└─────────────────┴─────────────────────┴─────────────┘\n```\n\n### Focused Layout (15% / 25% / 60%)\n```\n┌──────┬────────────┬────────────────────────────────────────┐\n│ EVTS │ CONTEXT    │ AGENT FOCUS: CodeWriterAgent           │\n│      │            │ ──────────────────────────────────────  │\n│ 1. > │ Jazz Test  │                                        │\n│ 2. + │ Elapsed:   │ Status: idle                           │\n│ 3. + │ 27s        │ Current Task: (none)                   │\n│ 4. > │            │ Last Activity: 3s ago                  │\n│ 5. # │ [DONE]     │                                        │\n│      │            │ Capabilities                           │\n│      │            │ ├─ Code generation (Kotlin, Python)    │\n│      │            │ ├─ File manipulation                   │\n│      │            │ └─ Test execution                      │\n│      │            │                                        │\n│      │            │ Memory                                 │\n│      │            │ ├─ Usage: 0% [──────────────────────]  │\n│      │            │ ├─ Recalled: 0 items                   │\n│      │            │ └─ Stored: 0 items                     │\n│      │            │                                        │\n│      │            │ Recent Cognitive Cycles                │\n│      │            │ └─ Jazz Test (27s) ✓ Complete          │\n└──────┴────────────┴────────────────────────────────────────┘\n```\n\n## Technical Approach\n\n### Step 1: Create Layout State Machine\n\n```kotlin\nsealed class LayoutMode {\n    object Normal : LayoutMode()\n    data class AgentFocus(val agentIndex: Int) : LayoutMode()\n    // Future: EventFocus, MemoryFocus, etc.\n}\n\nclass LayoutController {\n    private val _mode = MutableStateFlow<LayoutMode>(LayoutMode.Normal)\n    val mode: StateFlow<LayoutMode> = _mode.asStateFlow()\n    \n    fun focusAgent(index: Int) {\n        _mode.value = LayoutMode.AgentFocus(index)\n    }\n    \n    fun returnToNormal() {\n        _mode.value = LayoutMode.Normal\n    }\n    \n    fun getColumnWidths(): Triple<Int, Int, Int> = when (mode.value) {\n        is LayoutMode.Normal -> Triple(35, 40, 25)\n        is LayoutMode.AgentFocus -> Triple(15, 25, 60)\n    }\n}\n```\n\n### Step 2: Create Compressed Pane Renderers\n\n1. Compressed Event Stream (15% width):\n```kotlin\nfun renderCompressedEventStream(events: List<Event>, width: Int): List<String> {\n    return events.take(9).mapIndexed { index, event ->\n        val icon = event.icon  // \">\" \"+\" \"<\" etc.\n        \"${index + 1}. $icon\".padEnd(width)\n    }\n}\n```\n\n2. Compressed Context Pane (25% width):\n```kotlin\nfun renderCompressedContext(testState: JazzTestState, width: Int): List<String> {\n    return listOf(\n        \"Jazz Test\".padEnd(width),\n        \"Elapsed:\".padEnd(width),\n        testState.elapsed.formatShort().padEnd(width),\n        \"\".padEnd(width),\n        testState.completionBadge().padEnd(width)\n    )\n}\n```\n\n3. Expanded Agent Pane (60% width):\n```kotlin\nfun renderExpandedAgentPane(agent: Agent, width: Int): List<String> {\n    return buildList {\n        add(\"AGENT FOCUS: ${agent.name}\".padEnd(width))\n        add(\"─\".repeat(width))\n        add(\"\")\n        add(\"Status: ${agent.status}\")\n        add(\"Current Task: ${agent.currentTask?.title ?: \"(none)\"}\")\n        add(\"Last Activity: ${agent.lastActivity.ago()}\")\n        add(\"\")\n        add(\"Capabilities\")\n        agent.capabilities.forEach { cap ->\n            add(\"├─ $cap\")\n        }\n        // ... memory, recent cycles, etc.\n    }\n}\n```\n\n### Step 3: Update Input Handler\n\n```kotlin\nfun handleInput(key: KeyEvent, layoutController: LayoutController) {\n    when {\n        key.code == KeyCode.ESCAPE -> layoutController.returnToNormal()\n        \n        key.char == 'a' -> {\n            // Enter agent selection mode, wait for 1-9\n            awaitingAgentSelection = true\n        }\n        \n        awaitingAgentSelection && key.char in '1'..'9' -> {\n            layoutController.focusAgent(key.char.digitToInt())\n            awaitingAgentSelection = false\n        }\n        \n        // In focus mode, allow direct 1-9 to switch agents\n        layoutController.mode.value is LayoutMode.AgentFocus && key.char in '1'..'9' -> {\n            layoutController.focusAgent(key.char.digitToInt())\n        }\n    }\n}\n```\n\n### Step 4: Update Main Render Loop\n\n```kotlin\nfun render(state: AppState, layout: LayoutController) {\n    val (leftWidth, midWidth, rightWidth) = layout.getColumnWidths()\n    \n    val leftPane = when (layout.mode.value) {\n        is LayoutMode.Normal -> renderEventStream(state.events, leftWidth)\n        is LayoutMode.AgentFocus -> renderCompressedEventStream(state.events, leftWidth)\n    }\n    \n    val midPane = when (layout.mode.value) {\n        is LayoutMode.Normal -> renderJazzTest(state.jazzTest, midWidth)\n        is LayoutMode.AgentFocus -> renderCompressedContext(state.jazzTest, midWidth)\n    }\n    \n    val rightPane = when (val mode = layout.mode.value) {\n        is LayoutMode.Normal -> renderAgentSummary(state.activeAgent, rightWidth)\n        is LayoutMode.AgentFocus -> renderExpandedAgentPane(\n            state.agents[mode.agentIndex], \n            rightWidth\n        )\n    }\n    \n    composePanes(leftPane, midPane, rightPane)\n}\n```\n\n### Step 5: Add Transition Animation (Optional Enhancement)\n\nFor extra polish, animate the column width transition over 3-4 frames:\n\n```kotlin\nfun animateLayoutTransition(\n    from: Triple<Int, Int, Int>,\n    to: Triple<Int, Int, Int>,\n    frames: Int = 4\n): Sequence<Triple<Int, Int, Int>> = sequence {\n    for (i in 1..frames) {\n        val t = i.toFloat() / frames\n        yield(Triple(\n            lerp(from.first, to.first, t),\n            lerp(from.second, to.second, t),\n            lerp(from.third, to.third, t)\n        ))\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] `a` then `1` expands agent 1 to 60% width drawer\n- [ ] Event stream shows compressed format with numbers and icons only\n- [ ] ESC returns to normal layout\n- [ ] Can switch agents with `1-9` while in focus mode\n- [ ] Focus mode shows expanded agent details (status, capabilities, memory, history)\n- [ ] No visual glitches during layout transition\n- [ ] Column alignment maintained at terminal widths 80-200 chars",
            "labels": ["enhancement", "cli", "ux", "p1"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": ["cli-green-rectangles-fix"]
        },
        {
            "localId": "cli-section-headers",
            "type": "Task",
            "title": "Add Section Header Separators and Spacing",
            "body": "## Context\n\nCurrent section headers (`EVENT STREAM`, `THE JAZZ TEST`, `AGENT`) blend into their content, making it hard to visually parse the interface. The lack of separation creates a \"wall of text\" effect where the eye has no anchor points.\n\nGood visual hierarchy uses **whitespace and separators as punctuation**. Headers should clearly demarcate sections like chapter titles in a book. The reader should be able to glance at the screen and immediately identify the three columns and their purposes.\n\n## Objective\n\nCreate clear visual separation between headers and content using subtle separators and consistent spacing.\n\n## Expected Outcomes\n\n- Headers are visually distinct from content below them\n- Consistent 1-line padding below headers before content starts\n- Subtle horizontal rule or border below headers\n- Improved scannability of the interface\n\n## Visual Design\n\n### Before\n```\nEVENT STREAM\n1. > MessagePosted 20:59\n   \"[e80c6ea3...]\" \n```\n\n### After\n```\nEVENT STREAM\n────────────────────────\n\n1. > MessagePosted 20:59\n   \"[e80c6ea3...]\" \n```\n\nOr with box-drawing characters for a lighter feel:\n```\nEVENT STREAM\n╶───────────────────────\n\n1. > MessagePosted 20:59\n```\n\n## Technical Approach\n\n### Step 1: Create Header Component\n\n```kotlin\nfun renderSectionHeader(title: String, width: Int): List<String> {\n    val header = cyan(title.uppercase())\n    val separator = dim(\"─\".repeat(width))\n    return listOf(\n        header.padEnd(width),\n        separator,\n        \"\"  // Blank line for padding\n    )\n}\n```\n\n### Step 2: Update Each Pane Renderer\n\n1. Event Stream pane:\n```kotlin\nfun renderEventStreamPane(events: List<Event>, width: Int): List<String> {\n    return buildList {\n        addAll(renderSectionHeader(\"EVENT STREAM\", width))\n        addAll(renderEventList(events, width))\n    }\n}\n```\n\n2. Jazz Test pane:\n```kotlin\nfun renderJazzTestPane(state: JazzTestState, width: Int): List<String> {\n    return buildList {\n        addAll(renderSectionHeader(\"THE JAZZ TEST\", width))\n        addAll(renderJazzTestContent(state, width))\n    }\n}\n```\n\n3. Agent pane:\n```kotlin\nfun renderAgentPane(agent: Agent, width: Int): List<String> {\n    return buildList {\n        addAll(renderSectionHeader(\"AGENT\", width))\n        addAll(renderAgentContent(agent, width))\n    }\n}\n```\n\n### Step 3: Adjust Content Line Counts\n\nSince headers now take 3 lines (title + separator + blank), reduce content area accordingly to maintain fixed total height:\n\n```kotlin\nval totalPaneHeight = 20  // or whatever the current height is\nval headerHeight = 3\nval contentHeight = totalPaneHeight - headerHeight\n```\n\n### Step 4: Consider Sub-Headers\n\nFor sections within panes (like \"Cognitive Cycle\" or \"MEMORY\"), use lighter styling:\n\n```kotlin\nfun renderSubHeader(title: String, width: Int): String {\n    return dim(title)\n}\n\n// Usage:\nadd(renderSubHeader(\"Cognitive Cycle\", width))\nadd(\"\")  // Smaller gap for sub-headers\n```\n\n## Validation Criteria\n\n- [ ] All three main panes have header + separator + blank line\n- [ ] Headers render in cyan (or configured header color)\n- [ ] Separators render in dim gray\n- [ ] Consistent blank line below separator before content\n- [ ] Sub-headers (Cognitive Cycle, MEMORY) use lighter styling\n- [ ] Total pane heights unchanged (content area reduced to accommodate headers)\n- [ ] No horizontal overflow at 80 char terminal width",
            "labels": ["enhancement", "cli", "ux", "p1"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": []
        },
        {
            "localId": "cli-uuid-truncation",
            "type": "Task",
            "title": "Implement UUID and ID Truncation",
            "body": "## Context\n\nFull UUIDs like `e80c6ea3-c092-4be2-bb1c-228d32e90f1d` consume valuable horizontal space without adding actionable information. Users rarely need full UUIDs—they need enough characters to distinguish between items and, when needed, a way to copy the full ID.\n\nThe screenshot shows UUIDs appearing in:\n- Event descriptions: `\"[e80c6ea3-c092-4be2-bb1c-228d32e90f1d]\"`\n- Ticket IDs: `Ticket: e80c6ea3-c092-4be2-b`\n- Agent IDs: `Agent: CodeWriterAgent`\n\nAgent names are already human-readable. UUIDs should be truncated to last 8 characters with an ellipsis prefix, providing uniqueness while saving 28+ characters per occurrence.\n\n## Objective\n\nTruncate all UUID displays to a human-friendly format while preserving full IDs for copy/reference when needed.\n\n## Expected Outcomes\n\n- UUIDs display as `…228d32e9` (ellipsis + last 8 chars)\n- Hovering or command can reveal full UUID when needed\n- Ticket references show friendly format: `ticket-…32e9` or just `…32e9`\n- ~30 characters saved per UUID occurrence\n- Visual consistency across all ID displays\n\n## Technical Approach\n\n### Step 1: Create ID Formatting Utilities\n\n```kotlin\nobject IdFormatter {\n    /**\n     * Truncates a UUID to last N characters with ellipsis.\n     * e80c6ea3-c092-4be2-bb1c-228d32e90f1d → …32e90f1d\n     */\n    fun truncateUuid(uuid: String, lastChars: Int = 8): String {\n        val clean = uuid.replace(\"-\", \"\")\n        return if (clean.length > lastChars) {\n            \"…${clean.takeLast(lastChars)}\"\n        } else {\n            clean\n        }\n    }\n    \n    /**\n     * Formats a ticket ID for display.\n     * e80c6ea3-c092-4be2-b → …4be2-b or ticket-…4be2b\n     */\n    fun formatTicketId(ticketId: String): String {\n        return truncateUuid(ticketId)\n    }\n    \n    /**\n     * Formats an agent ID, preferring name if available.\n     * CodeWriterAgent-abc123 → CodeWriter\n     */\n    fun formatAgentId(agentId: String, agentName: String?): String {\n        return agentName ?: truncateUuid(agentId)\n    }\n}\n```\n\n### Step 2: Update Event Rendering\n\n```kotlin\nfun renderEventLine(event: Event, width: Int): String {\n    val truncatedId = IdFormatter.truncateUuid(event.correlationId)\n    val description = event.description.replace(\n        Regex(\"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\", RegexOption.IGNORE_CASE)\n    ) { match -> IdFormatter.truncateUuid(match.value) }\n    \n    return \"$description\".take(width)\n}\n```\n\n### Step 3: Update Jazz Test Pane\n\n```kotlin\nfun renderJazzTestInfo(state: JazzTestState, width: Int): List<String> {\n    return listOf(\n        \"Ticket: ${IdFormatter.formatTicketId(state.ticketId)}\",\n        \"Agent: ${state.agentName}\"  // Already human-readable\n    )\n}\n```\n\n### Step 4: Add Full ID Access via Command\n\nFor cases where users need the full UUID:\n\n```kotlin\n// In command handler\nfun handleCommand(command: String) {\n    when {\n        command.startsWith(\":id \") -> {\n            val shortId = command.removePrefix(\":id \")\n            val fullId = idRegistry.lookupFull(shortId)\n            showToast(\"Full ID: $fullId (copied to clipboard)\")\n        }\n    }\n}\n```\n\n### Step 5: Consider Color Coding\n\nUse subtle color to distinguish IDs from regular text:\n\n```kotlin\nfun styledTruncatedId(uuid: String): String {\n    return dim(IdFormatter.truncateUuid(uuid))\n}\n```\n\n## Validation Criteria\n\n- [ ] All UUIDs in event stream display as `…XXXXXXXX` format\n- [ ] Ticket ID in Jazz Test pane shows truncated format\n- [ ] No full UUIDs visible in default view\n- [ ] `:id <shortId>` command shows full UUID\n- [ ] ID truncation consistent across all panes\n- [ ] Agent names remain unchanged (already human-readable)\n- [ ] Event descriptions with embedded UUIDs are truncated",
            "labels": ["enhancement", "cli", "ux", "p1"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": []
        },
        {
            "localId": "cli-event-formatting",
            "type": "Task",
            "title": "Improve Event Stream Entry Formatting",
            "body": "## Context\n\nEvent stream entries currently use 3 lines each with no separation between entries, creating a dense block that's hard to scan. The format:\n```\n1. > MessagePosted 20:59\n   \"[e80c6ea3...]\" \n   SYSTEM_ORCHESTRATOR\n```\n\nWhile information-rich, this layout has issues:\n- No visual break between entries\n- Agent name on its own line wastes vertical space\n- Quoted content feels cluttered with brackets and quotes\n- Timestamp at end of first line gets lost\n\n## Objective\n\nReformat event entries for better scannability while maintaining information density.\n\n## Expected Outcomes\n\n- Clear visual separation between events\n- Agent attribution integrated without separate line\n- Timestamps visually distinct but not prominent\n- Better use of available width\n- Reduced visual clutter\n\n## Visual Design Options\n\n### Option A: Compact with Separator\n```\n1. > MessagePosted                           20:59\n   [e80c6ea3] • SYSTEM_ORCHESTRATOR\n────────────────────────────────────────────────\n2. + TicketAssigned                          20:59\n   Assigned to CodeWriterAgent • human-jazz-demo\n────────────────────────────────────────────────\n```\n\n### Option B: Two-Line with Integrated Attribution\n```\n1. > MessagePosted • SYSTEM_ORCH            20:59\n   [e80c6ea3-c092-4be2-bb1c-228d32e90f1d]\n\n2. + TicketAssigned • human-jazz            20:59\n   Assigned to CodeWriterAgent\n```\n\n### Option C: Single-Line Compact (for older events)\n```\n1. > MsgPosted [e80c6ea3] SYSTEM_ORCH       20:59\n2. + Assigned → CodeWriter by human-jazz    20:59\n3. + Created \"Impl Fibonacci\" human-jazz    20:59\n────────────────────────────────────────────────\n4. > MsgPosted                               20:59 ← Expanded\n   \"Ticket Created: Implement Fibonacci fun\"\n   SYSTEM_ORCHESTRATOR\n```\n\n**Recommendation**: Option A provides the best balance of clarity and density.\n\n## Technical Approach\n\n### Step 1: Create Event Entry Component\n\n```kotlin\ndata class EventDisplayConfig(\n    val showSeparator: Boolean = true,\n    val maxDescriptionLength: Int = 50,\n    val timestampWidth: Int = 5\n)\n\nfun renderEventEntry(\n    index: Int,\n    event: Event,\n    width: Int,\n    config: EventDisplayConfig = EventDisplayConfig()\n): List<String> {\n    val icon = event.icon\n    val type = event.type.shortName  // \"MessagePosted\" → \"MsgPosted\"\n    val timestamp = dim(event.timestamp.format(\"HH:mm\"))\n    \n    // Line 1: Index, icon, type, right-aligned timestamp\n    val line1Content = \"$index. $icon $type\"\n    val line1 = line1Content + timestamp.padStart(width - line1Content.length)\n    \n    // Line 2: Description + agent attribution\n    val truncatedDesc = event.description.take(config.maxDescriptionLength)\n    val agent = cyan(event.sourceAgent.shortName)\n    val line2 = \"   $truncatedDesc • $agent\"\n    \n    // Optional separator\n    val separator = if (config.showSeparator) dim(\"─\".repeat(width)) else \"\"\n    \n    return listOfNotNull(\n        line1,\n        line2.take(width),\n        separator.takeIf { it.isNotEmpty() }\n    )\n}\n```\n\n### Step 2: Implement Adaptive Density\n\nShow expanded format for recent events, compact for older:\n\n```kotlin\nfun renderEventStream(events: List<Event>, width: Int, maxLines: Int): List<String> {\n    val result = mutableListOf<String>()\n    val recentCount = 3  // Show last 3 events expanded\n    \n    events.forEachIndexed { index, event ->\n        val isRecent = index >= events.size - recentCount\n        val config = if (isRecent) {\n            EventDisplayConfig(showSeparator = true)\n        } else {\n            EventDisplayConfig(showSeparator = false, maxDescriptionLength = 30)\n        }\n        \n        result.addAll(renderEventEntry(index + 1, event, width, config))\n    }\n    \n    return result.take(maxLines)\n}\n```\n\n### Step 3: Add Event Type Short Names\n\n```kotlin\nval Event.Type.shortName: String get() = when (this) {\n    MessagePosted -> \"MsgPosted\"\n    TicketAssigned -> \"Assigned\"\n    TicketCreated -> \"Created\"\n    ThreadCreated -> \"Thread\"\n    KnowledgeRecalled -> \"Recalled\"\n    KnowledgeStored -> \"Stored\"\n    // ...\n}\n\nval Event.icon: String get() = when (this.type) {\n    MessagePosted -> \">\"\n    TicketAssigned -> \"+\"\n    TicketCreated -> \"+\"\n    ThreadCreated -> \"#\"\n    KnowledgeRecalled -> \"<\"\n    KnowledgeStored -> \">\"\n    // ...\n}\n```\n\n### Step 4: Handle Long Descriptions\n\n```kotlin\nfun truncateDescription(description: String, maxLength: Int): String {\n    return if (description.length <= maxLength) {\n        description\n    } else {\n        description.take(maxLength - 1) + \"…\"\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] Events have visual separation (blank line or separator)\n- [ ] Agent attribution on same line as description (saves vertical space)\n- [ ] Timestamps right-aligned and dimmed\n- [ ] Long descriptions truncated with ellipsis\n- [ ] Recent events more detailed, older events more compact\n- [ ] Event icons consistent and single-width\n- [ ] No horizontal overflow at 80 char terminal width",
            "labels": ["enhancement", "cli", "ux", "p2"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": ["cli-section-headers", "cli-uuid-truncation"]
        },
        {
            "localId": "cli-status-bar-layout",
            "type": "Task",
            "title": "Refine Status Bar Layout and Shortcuts",
            "body": "## Context\n\nThe current status bar packs shortcuts densely:\n```\n[a]gent [d]ashboard [e]vents [m]emory [v]erbose [h]help [q]uit    Status: WORKING\n```\n\nWhile functional, this has issues:\n- Dense and hard to parse quickly\n- Active mode not clearly distinguished from inactive\n- No visual grouping of related shortcuts\n- Status label could be more prominent\n\nThe status bar is **prime real estate**—the user's eye naturally rests there. It should communicate:\n1. What mode am I in? (immediately obvious)\n2. What can I do? (available actions)\n3. What's happening? (system status)\n\n## Objective\n\nRedesign the status bar for clarity, visual grouping, and prominent status indication.\n\n## Expected Outcomes\n\n- Active mode visually distinct (inverse, underline, or bold)\n- Related shortcuts grouped with separators\n- System status prominent and colored by state\n- Cleaner overall appearance\n- Clear indication when awaiting input (e.g., after pressing `a`)\n\n## Visual Design Options\n\n### Option A: Grouped with Separators\n```\nViews: [a]gent [d]ash [e]vents [m]em │ [v]erbose [h]elp [q]uit │ ● WORKING\n```\n\n### Option B: Active Mode Highlighted\n```\na·agent  d·dash  [e]·EVENTS  m·mem │ v·verbose  h·help  q·quit │ ◉ WORKING\n```\n(Active mode `[e]·EVENTS` shown with brackets and caps)\n\n### Option C: Minimal with Prominent Status\n```\na d [e] m v h q                                              ● WORKING\n```\n(Assumes users learn shortcuts; status dominates)\n\n### Option D: Full Descriptions for Active Only\n```\na  d  EVENTS  m │ verbose  help  quit                        ● WORKING\n```\n\n**Recommendation**: Option A with active mode styling from Option B.\n\n## Technical Approach\n\n### Step 1: Define Status Bar State\n\n```kotlin\ndata class StatusBarState(\n    val activeMode: ViewMode,\n    val systemStatus: SystemStatus,\n    val pendingInput: PendingInput? = null,\n    val verboseEnabled: Boolean = false\n)\n\nsealed class ViewMode {\n    object Agent : ViewMode()\n    object Dashboard : ViewMode()\n    object Events : ViewMode()\n    object Memory : ViewMode()\n}\n\nsealed class PendingInput {\n    object AwaitingAgentNumber : PendingInput()\n    object AwaitingCommand : PendingInput()\n}\n```\n\n### Step 2: Create Shortcut Renderer\n\n```kotlin\nfun renderShortcut(key: Char, label: String, isActive: Boolean): String {\n    return if (isActive) {\n        // Active: bracketed, uppercase, highlighted\n        cyan(\"[$key]·${label.uppercase()}\")\n    } else {\n        // Inactive: lowercase, dimmed key\n        dim(\"$key\") + \"·\" + label\n    }\n}\n\nfun renderShortcutGroup(shortcuts: List<Triple<Char, String, Boolean>>): String {\n    return shortcuts.joinToString(\"  \") { (key, label, active) ->\n        renderShortcut(key, label, active)\n    }\n}\n```\n\n### Step 3: Create Status Indicator\n\n```kotlin\nfun renderStatusIndicator(status: SystemStatus): String {\n    val (icon, color, label) = when (status) {\n        SystemStatus.Idle -> Triple(\"○\", ::dim, \"IDLE\")\n        SystemStatus.Thinking -> Triple(\"◐\", ::yellow, \"THINKING\")\n        SystemStatus.Working -> Triple(\"●\", ::green, \"WORKING\")\n        SystemStatus.Waiting -> Triple(\"◑\", ::blue, \"WAITING\")\n        is SystemStatus.Completed -> Triple(\"✓\", ::green, \"COMPLETED\")\n        is SystemStatus.Error -> Triple(\"✗\", ::red, \"ERROR\")\n    }\n    return color(\"$icon $label\")\n}\n```\n\n### Step 4: Compose Status Bar\n\n```kotlin\nfun renderStatusBar(state: StatusBarState, width: Int): String {\n    val viewShortcuts = renderShortcutGroup(listOf(\n        Triple('a', \"agent\", state.activeMode == ViewMode.Agent),\n        Triple('d', \"dash\", state.activeMode == ViewMode.Dashboard),\n        Triple('e', \"events\", state.activeMode == ViewMode.Events),\n        Triple('m', \"mem\", state.activeMode == ViewMode.Memory)\n    ))\n    \n    val actionShortcuts = renderShortcutGroup(listOf(\n        Triple('v', \"verbose\", state.verboseEnabled),\n        Triple('h', \"help\", false),\n        Triple('q', \"quit\", false)\n    ))\n    \n    val status = renderStatusIndicator(state.systemStatus)\n    \n    val separator = dim(\"│\")\n    val leftPart = \"$viewShortcuts $separator $actionShortcuts\"\n    val rightPart = status\n    \n    val padding = width - leftPart.visualLength() - rightPart.visualLength()\n    return leftPart + \" \".repeat(maxOf(1, padding)) + rightPart\n}\n```\n\n### Step 5: Handle Pending Input State\n\n```kotlin\nfun renderStatusBarWithPendingInput(state: StatusBarState, width: Int): String {\n    return when (state.pendingInput) {\n        is PendingInput.AwaitingAgentNumber -> {\n            val prompt = cyan(\": agent [1-9]\") + dim(\" [ESC cancel]\")\n            val status = renderStatusIndicator(state.systemStatus)\n            val padding = width - prompt.visualLength() - status.visualLength()\n            prompt + \" \".repeat(maxOf(1, padding)) + status\n        }\n        is PendingInput.AwaitingCommand -> {\n            val prompt = cyan(\":\")\n            prompt + \"_\".repeat(width - prompt.visualLength() - 1)\n        }\n        null -> renderStatusBar(state, width)\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] Active mode visually distinct (brackets, uppercase, color)\n- [ ] View shortcuts grouped separately from action shortcuts\n- [ ] Separator (`│`) between groups\n- [ ] System status right-aligned with colored indicator\n- [ ] Pending input shows prompt with cancel hint\n- [ ] No overflow at 80 char terminal width\n- [ ] Status updates immediately when mode changes",
            "labels": ["enhancement", "cli", "ux", "p2"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": ["cli-status-sync-fix"]
        },
        {
            "localId": "cli-empty-states",
            "type": "Task",
            "title": "Enhance Right Pane Empty States",
            "body": "## Context\n\nWhen an agent is idle with 0% memory and no activity, the right pane feels hollow:\n```\nAGENT\n\nCodeWriter\n  idle\n\nPhase:\nCompleted\n\nMEMORY\n[-----------------------------] 0%\n\n< 0 ..............................\n> 0 ..............................\n```\n\nEmpty states are an opportunity, not a problem. They should communicate:\n1. The system is working correctly (not broken)\n2. What could/will appear here when active\n3. Useful context even when idle\n\nThe current display wastes space and communicates nothing useful. Those dotted lines for `< 0` and `> 0` are cryptic even when populated—incomprehensible when empty.\n\n## Objective\n\nTransform empty states from hollow placeholders into informative, contextual displays.\n\n## Expected Outcomes\n\n- Idle agents show last activity timestamp and capabilities\n- Empty memory shows explanatory text, not just \"0%\"\n- Recall/store indicators explained or hidden when zero\n- Activity sparkline shows baseline or message when no data\n- Overall impression: \"ready and waiting\" not \"broken and empty\"\n\n## Visual Design\n\n### Before (Current)\n```\nAGENT\n\nCodeWriter\n  idle\n\nPhase:\nCompleted\n\nMEMORY\n[-----------------------------] 0%\n\n< 0 ..............................\n> 0 ..............................\n```\n\n### After (Proposed)\n```\nAGENT\n────────────────────────────────\n\nCodeWriter\n● idle • last active 3s ago\n\nPhase: Completed ✓\n\n─── MEMORY ───────────────────\n\nUsage: 0%\n[                              ]\n\nRecalled: 0 items\nStored: 0 items\n\n─── CAPABILITIES ─────────────\n\n• Kotlin/Java code generation\n• File read/write operations\n• Test execution & validation\n```\n\n### Alternative: Collapsed Empty State\nWhen there's truly nothing to show, collapse to minimal:\n```\nAGENT\n────────────────────────────────\n\nCodeWriter\n● idle\n\nNo recent activity.\nPress [a][1] to view details.\n```\n\n## Technical Approach\n\n### Step 1: Create Empty State Components\n\n```kotlin\nfun renderAgentEmptyState(agent: Agent, width: Int): List<String> {\n    return buildList {\n        add(renderSectionHeader(\"AGENT\", width))\n        add(\"\")\n        add(agent.name)\n        add(\"${statusIcon(agent.status)} ${agent.status.displayName} • last active ${agent.lastActive.ago()}\")\n        add(\"\")\n        \n        if (agent.lastPhase != null) {\n            add(\"Phase: ${agent.lastPhase} ${if (agent.lastPhaseComplete) \"✓\" else \"\"}\")\n            add(\"\")\n        }\n        \n        add(renderSubHeader(\"CAPABILITIES\", width))\n        add(\"\")\n        agent.capabilities.forEach { cap ->\n            add(\"• $cap\")\n        }\n    }\n}\n```\n\n### Step 2: Create Informative Memory Display\n\n```kotlin\nfun renderMemorySection(memory: AgentMemory, width: Int): List<String> {\n    return buildList {\n        add(renderSubHeader(\"MEMORY\", width))\n        add(\"\")\n        \n        if (memory.isEmpty()) {\n            add(dim(\"No memories stored yet.\"))\n            add(dim(\"Memories accumulate as agent learns.\"))\n        } else {\n            add(\"Usage: ${memory.usagePercent}%\")\n            add(renderProgressBar(memory.usagePercent, width - 2))\n            add(\"\")\n            add(\"Recalled: ${memory.recallCount} items\")\n            add(\"Stored: ${memory.storeCount} items\")\n            \n            if (memory.recentTags.isNotEmpty()) {\n                add(\"\")\n                add(\"Recent: ${memory.recentTags.take(3).joinToString(\", \")}\")\n            }\n        }\n    }\n}\n\nfun renderProgressBar(percent: Int, width: Int): String {\n    val filled = (width * percent / 100).coerceIn(0, width)\n    val empty = width - filled\n    return \"[\" + \"█\".repeat(filled) + \" \".repeat(empty) + \"]\"\n}\n```\n\n### Step 3: Add Agent Capabilities Registry\n\n```kotlin\nval Agent.capabilities: List<String> get() = when (this) {\n    is CodeWriterAgent -> listOf(\n        \"Kotlin/Java code generation\",\n        \"File read/write operations\",\n        \"Test execution & validation\"\n    )\n    is ProductManagerAgent -> listOf(\n        \"Goal decomposition\",\n        \"Task assignment\",\n        \"Progress monitoring\"\n    )\n    // ...\n}\n```\n\n### Step 4: Track Last Activity\n\n```kotlin\nclass Agent {\n    private var _lastActiveTime: Instant = Instant.now()\n    \n    val lastActive: Instant get() = _lastActiveTime\n    \n    fun markActive() {\n        _lastActiveTime = Instant.now()\n    }\n}\n\nfun Instant.ago(): String {\n    val seconds = Duration.between(this, Instant.now()).seconds\n    return when {\n        seconds < 60 -> \"${seconds}s ago\"\n        seconds < 3600 -> \"${seconds / 60}m ago\"\n        else -> \"${seconds / 3600}h ago\"\n    }\n}\n```\n\n### Step 5: Remove Cryptic Indicators\n\nReplace `< 0 ......` and `> 0 ......` with clear labels:\n\n```kotlin\n// Before (cryptic)\nadd(\"< $recallCount ${dots(30)}\")\nadd(\"> $storeCount ${dots(30)}\")\n\n// After (clear)\nadd(\"Recalled: $recallCount items\")\nadd(\"Stored: $storeCount items\")\n```\n\n## Validation Criteria\n\n- [ ] Idle agent shows last activity timestamp\n- [ ] Agent capabilities listed when idle\n- [ ] Empty memory shows explanatory text, not just bars\n- [ ] Recall/store counts use words (\"items\") not just symbols\n- [ ] No cryptic indicators (`< 0 ....`)\n- [ ] Progress bar renders correctly at 0%\n- [ ] Overall appearance is informative, not hollow\n- [ ] Collapsed state available for minimal view option",
            "labels": ["enhancement", "cli", "ux", "p2"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": ["cli-section-headers"]
        },
        {
            "localId": "cli-cognitive-tree",
            "type": "Task",
            "title": "Implement Cognitive Cycle Tree View",
            "body": "## Context\n\nThe cognitive cycle display currently shows phases as a flat list:\n```\n✓ PERCEIVE   Complete\n  Ideas generated: 1\n\n✓ PLAN       Complete\n  Steps: 1  Complexity: 2\n\n✓ EXECUTE    Complete\n  → Fibonacci.kt\n\n✓ LEARN      Complete\n```\n\nThis misses an opportunity to visualize the **flow** of cognition. The PROPEL cycle (PERCEIVE → PLAN → EXECUTE → LEARN) is a connected pipeline, not isolated boxes. A tree view with connecting lines would better communicate this architecture while being more visually appealing.\n\n## Objective\n\nRender the cognitive cycle as a connected tree structure that emphasizes the flow of information through phases.\n\n## Expected Outcomes\n\n- Phases connected with tree-drawing characters (├─, └─, │)\n- Active phase clearly highlighted with animation\n- Completed phases show results inline\n- Visual flow from top to bottom mirrors cognitive flow\n- Handles variable detail levels gracefully\n\n## Visual Design\n\n### Standard View (All Complete)\n```\nCognitive Cycle\n├─ ✓ PERCEIVE   Complete\n│     Ideas generated: 1\n│\n├─ ✓ PLAN       Complete\n│     Steps: 1  Complexity: 2\n│\n├─ ✓ EXECUTE    Complete\n│     → Fibonacci.kt\n│\n└─ ✓ LEARN      Complete\n```\n\n### In-Progress View (Execute Active)\n```\nCognitive Cycle\n├─ ✓ PERCEIVE   Complete\n│     Ideas generated: 1\n│\n├─ ✓ PLAN       Complete\n│     Steps: 1  Complexity: 2\n│\n├─ ϟ EXECUTE    In Progress (12s)\n│     Writing Fibonacci.kt...\n│\n└─ ○ LEARN      Pending\n```\n\n### Compact View (No Details)\n```\nCognitive Cycle\n├─✓ PERCEIVE  ├─✓ PLAN  ├─ϟ EXECUTE  └─○ LEARN\n```\n\n## Technical Approach\n\n### Step 1: Define Phase Display Model\n\n```kotlin\ndata class PhaseDisplay(\n    val phase: CognitivePhase,\n    val status: PhaseStatus,\n    val details: List<String>,\n    val elapsed: Duration? = null\n)\n\nenum class PhaseStatus {\n    PENDING,\n    IN_PROGRESS,\n    COMPLETE,\n    SKIPPED,\n    FAILED\n}\n\nfun PhaseStatus.icon(): String = when (this) {\n    PENDING -> \"○\"\n    IN_PROGRESS -> \"ϟ\"  // Animated in render\n    COMPLETE -> \"✓\"\n    SKIPPED -> \"⊘\"\n    FAILED -> \"✗\"\n}\n\nfun PhaseStatus.color(): (String) -> String = when (this) {\n    PENDING -> ::dim\n    IN_PROGRESS -> ::yellow\n    COMPLETE -> ::green\n    SKIPPED -> ::dim\n    FAILED -> ::red\n}\n```\n\n### Step 2: Create Tree Renderer\n\n```kotlin\nfun renderCognitiveTree(\n    phases: List<PhaseDisplay>,\n    width: Int,\n    showDetails: Boolean = true\n): List<String> {\n    return buildList {\n        add(\"Cognitive Cycle\")\n        \n        phases.forEachIndexed { index, phase ->\n            val isLast = index == phases.lastIndex\n            val prefix = if (isLast) \"└─\" else \"├─\"\n            val continuePrefix = if (isLast) \"  \" else \"│ \"\n            \n            val icon = phase.status.icon()\n            val colorFn = phase.status.color()\n            val statusText = when (phase.status) {\n                PhaseStatus.IN_PROGRESS -> \"In Progress\" + \n                    phase.elapsed?.let { \" (${it.seconds}s)\" }.orEmpty()\n                else -> phase.status.name.lowercase().capitalize()\n            }\n            \n            // Main phase line\n            add(\"$prefix ${colorFn(icon)} ${colorFn(phase.phase.name.padEnd(10))} $statusText\")\n            \n            // Detail lines\n            if (showDetails && phase.details.isNotEmpty()) {\n                phase.details.forEach { detail ->\n                    add(\"$continuePrefix    ${dim(detail)}\")\n                }\n            }\n            \n            // Spacer between phases (except last)\n            if (!isLast) {\n                add(\"│\")\n            }\n        }\n    }\n}\n```\n\n### Step 3: Add Animation for In-Progress\n\n```kotlin\nclass PhaseAnimator {\n    private val frames = listOf(\"ϟ\", \"϶\", \"϶\", \"ϟ\")  // Lightning flicker\n    private var frameIndex = 0\n    \n    fun nextFrame(): String {\n        val frame = frames[frameIndex]\n        frameIndex = (frameIndex + 1) % frames.size\n        return frame\n    }\n}\n\n// In render loop\nfun renderAnimatedIcon(status: PhaseStatus, animator: PhaseAnimator): String {\n    return if (status == PhaseStatus.IN_PROGRESS) {\n        animator.nextFrame()\n    } else {\n        status.icon()\n    }\n}\n```\n\n### Step 4: Extract Phase Details from Events\n\n```kotlin\nfun extractPhaseDetails(phase: CognitivePhase, events: List<Event>): List<String> {\n    return when (phase) {\n        CognitivePhase.PERCEIVE -> {\n            val ideas = events.filterIsInstance<IdeasGenerated>().lastOrNull()\n            ideas?.let { listOf(\"Ideas generated: ${it.count}\") } ?: emptyList()\n        }\n        CognitivePhase.PLAN -> {\n            val plan = events.filterIsInstance<PlanCreated>().lastOrNull()\n            plan?.let { listOf(\"Steps: ${it.stepCount}  Complexity: ${it.complexity}\") } ?: emptyList()\n        }\n        CognitivePhase.EXECUTE -> {\n            val outputs = events.filterIsInstance<FileCreated>().takeLast(3)\n            outputs.map { \"→ ${it.filename}\" }\n        }\n        CognitivePhase.LEARN -> {\n            val learnings = events.filterIsInstance<KnowledgeStored>().lastOrNull()\n            learnings?.let { listOf(\"Stored: ${it.tags.joinToString(\", \")}\") } ?: emptyList()\n        }\n    }\n}\n```\n\n### Step 5: Integrate with Jazz Test Pane\n\n```kotlin\nfun renderJazzTestContent(state: JazzTestState, width: Int): List<String> {\n    return buildList {\n        add(\"Elapsed: ${state.elapsed.format()}\")\n        add(\"\")\n        add(\"Ticket: ${IdFormatter.formatTicketId(state.ticketId)}\")\n        add(\"Agent: ${state.agentName}\")\n        add(\"\")\n        addAll(renderCognitiveTree(state.phases, width))\n        add(\"\")\n        \n        if (state.isComplete) {\n            add(green(\"[COMPLETED]\"))\n        }\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] Phases render with tree-drawing characters (├─, └─, │)\n- [ ] Completed phases show green checkmark\n- [ ] In-progress phase shows animated lightning bolt\n- [ ] Pending phases show dim circle\n- [ ] Phase details indented under their phase\n- [ ] Vertical connector lines align properly\n- [ ] Tree renders correctly at various terminal widths\n- [ ] Animation updates at TUI refresh rate (4 FPS)",
            "labels": ["enhancement", "cli", "ux", "p3"],
            "parent": "cli-ux-polish-epic",
            "dependsOn": ["cli-section-headers"]
        }
    ]
}
