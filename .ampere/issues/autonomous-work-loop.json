{
  "repository": "socket-link/ampere",
  "issues": [
    {
      "localId": "auto-work-loop-epic",
      "type": "Feature",
      "title": "Autonomous Work Loop for CodeAgent",
      "body": "## Context\n\nCurrently, CodeAgent has all the infrastructure to work on GitHub issues (issue discovery, status updates, Git operations, PR creation) but lacks the autonomous work loop to continuously discover and work on issues. The agent sits idle waiting for explicit commands.\n\n## Objective\n\nImplement a complete autonomous work loop that enables CodeAgent to:\n- Continuously poll for available GitHub issues\n- Claim issues using optimistic locking (GitHub labels)\n- Execute the full issue-to-PR workflow\n- Handle errors and retries gracefully\n- Integrate with the CLI for user control\n\n## Expected Outcomes\n\n1. CodeAgent can autonomously work on issues labeled with 'code'\n2. Users can trigger autonomous mode via `ampere work` or `ampere start --auto-work`\n3. Issue status is tracked via GitHub labels (assigned → in-progress → in-review)\n4. Error handling prevents infinite loops and marks blocked issues\n5. Full observability through event system and dashboard\n\n## Implementation Phases\n\n**Phase 1: Critical Blockers** - Fix foundation issues that block all other work\n**Phase 2: Core Work Loop** - Implement the autonomous polling and execution engine\n**Phase 3: Integration & Testing** - Wire into CLI and validate end-to-end\n\n## Design Document\n\nSee `.ampere/docs/autonomous-work-loop-design.md` for complete architecture and design decisions.\n\n## Success Criteria\n\n- [ ] Agent discovers issues with 'code' label\n- [ ] Agent claims issues without race conditions\n- [ ] Agent executes full workflow (code → branch → commit → PR)\n- [ ] Issue labels accurately reflect workflow status\n- [ ] CLI commands work as designed\n- [ ] Integration tests pass\n- [ ] Error scenarios handled gracefully",
      "labels": ["feature", "agent", "code", "autonomous"],
      "assignees": [],
      "parent": null,
      "dependsOn": []
    },
    {
      "localId": "auto-work-loop-fix-labels",
      "type": "Task",
      "title": "Fix GitHubCliProvider to support label updates",
      "body": "## Context\n\nThe GitHubCliProvider has a critical bug where `updateIssue()` silently ignores label updates. Lines 292-294 contain a TODO comment:\n\n```kotlin\n// Labels and assignees require separate API calls\n// For now, we skip these in the update implementation\n// Future: Use gh api to update labels and assignees\n```\n\nThis means `CodeAgent.updateIssueStatus()` calls fail silently - labels never change, breaking the entire workflow status tracking system.\n\n## Objective\n\nImplement label update support in GitHubCliProvider using `gh` CLI commands.\n\n## Implementation Details\n\n**File**: `ampere-core/src/jvmMain/kotlin/link/socket/ampere/integrations/issues/github/GitHubCliProvider.kt`\n\n**Approach**: Modify `updateIssue()` method around line 292 to handle label updates:\n\n```kotlin\n// Add label update logic\nupdate.labels?.let { newLabels ->\n    // Fetch current labels\n    val currentIssue = queryIssues(\n        repository = repository,\n        query = IssueQuery(limit = 1, /* filter by number */)\n    ).getOrNull()?.firstOrNull()\n    \n    val currentLabels = currentIssue?.labels ?: emptyList()\n    \n    // Determine labels to add and remove\n    val toAdd = newLabels - currentLabels.toSet()\n    val toRemove = currentLabels - newLabels.toSet()\n    \n    // Use gh issue edit with --add-label and --remove-label\n    toAdd.forEach { label ->\n        executeGh(\"issue\", \"edit\", issueNumber.toString(), \n                 \"--repo\", repository,\n                 \"--add-label\", label)\n    }\n    \n    toRemove.forEach { label ->\n        executeGh(\"issue\", \"edit\", issueNumber.toString(),\n                 \"--repo\", repository, \n                 \"--remove-label\", label)\n    }\n}\n```\n\n**Alternative**: Use `gh api` for atomic label replacement:\n```bash\ngh api repos/OWNER/REPO/issues/123/labels -f labels='[\"label1\",\"label2\"]'\n```\n\n## Validation Criteria\n\n- [ ] Create a test issue\n- [ ] Call `updateIssue()` with new labels\n- [ ] Verify labels actually change on GitHub\n- [ ] Existing tests in `IssueTrackerProviderTest.kt` pass\n- [ ] Add new test case for label updates\n\n## Files to Modify\n\n- `ampere-core/src/jvmMain/kotlin/link/socket/ampere/integrations/issues/github/GitHubCliProvider.kt` (lines 292-294)\n- `ampere-core/src/commonTest/kotlin/link/socket/ampere/integrations/issues/IssueTrackerProviderTest.kt` (add test)",
      "labels": ["task", "code", "bug-fix"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": []
    },
    {
      "localId": "auto-work-loop-wire-provider",
      "type": "Task",
      "title": "Wire IssueTrackerProvider to CodeAgent via AgentFactory",
      "body": "## Context\n\nCurrently, `AgentFactory.create()` instantiates `CodeAgent` without passing `issueTrackerProvider` or `repository` parameters. This means the agent can't query or update GitHub issues.\n\n**Current code** (AgentFactory.kt lines 51-56):\n```kotlin\nAgentType.CODE -> CodeAgent(\n    agentConfiguration = agentConfiguration,\n    toolWriteCodeFile = toolWriteCodeFile,\n    coroutineScope = scope,\n    memoryServiceFactory = memoryServiceFactory,\n    // ❌ Missing: issueTrackerProvider\n    // ❌ Missing: repository\n) as A\n```\n\n## Objective\n\nWire up `GitHubCliProvider` and repository detection to `CodeAgent` so it can interact with GitHub issues.\n\n## Implementation Details\n\n**File**: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/AgentFactory.kt`\n\n**Step 1**: Add IssueTrackerProvider to AgentFactory constructor\n```kotlin\nclass AgentFactory(\n    private val scope: CoroutineScope,\n    private val ticketOrchestrator: TicketOrchestrator,\n    private val aiConfigurationFactory: AIConfigurationFactory,\n    private val memoryServiceFactory: ((AgentId) -> AgentMemoryService)? = null,\n    private val issueTrackerProvider: IssueTrackerProvider? = null, // NEW\n    private val repository: String? = null, // NEW\n)\n```\n\n**Step 2**: Pass to CodeAgent\n```kotlin\nAgentType.CODE -> CodeAgent(\n    agentConfiguration = agentConfiguration,\n    toolWriteCodeFile = toolWriteCodeFile,\n    coroutineScope = scope,\n    memoryServiceFactory = memoryServiceFactory,\n    issueTrackerProvider = issueTrackerProvider, // NEW\n    repository = repository, // NEW\n) as A\n```\n\n**Step 3**: Update Main.kt to create and pass GitHubCliProvider\n```kotlin\n// In Main.kt\nimport link.socket.ampere.integrations.issues.github.GitHubCliProvider\n\nval issueProvider = GitHubCliProvider()\nval repository = detectRepository() // From auto-work-loop-repo-detect task\n\nval agentFactory = AgentFactory(\n    scope = ioScope,\n    ticketOrchestrator = environmentService.ticketOrchestrator,\n    aiConfigurationFactory = aiConfigurationFactory,\n    memoryServiceFactory = { agentId -> context.createMemoryService(agentId) },\n    issueTrackerProvider = issueProvider, // NEW\n    repository = repository, // NEW\n)\n```\n\n## Validation Criteria\n\n- [ ] AgentFactory compiles with new parameters\n- [ ] CodeAgent receives non-null issueTrackerProvider\n- [ ] Call `codeAgent.queryAvailableIssues()` successfully returns issues\n- [ ] Existing tests pass\n\n## Files to Modify\n\n- `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/AgentFactory.kt` (lines 24-56)\n- `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/Main.kt` (around line 49)",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-fix-labels"]
    },
    {
      "localId": "auto-work-loop-repo-detect",
      "type": "Task",
      "title": "Implement repository detection from git remote",
      "body": "## Context\n\nCodeAgent needs to know which GitHub repository to query for issues. Rather than requiring users to specify `--repo owner/name` every time, we should auto-detect from the current git repository.\n\n## Objective\n\nImplement a `detectRepository()` function that extracts the repository from `git remote get-url origin`.\n\n## Implementation Details\n\n**New file**: `ampere-core/src/jvmMain/kotlin/link/socket/ampere/integrations/git/RepositoryDetector.kt`\n\n```kotlin\npackage link.socket.ampere.integrations.git\n\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n/**\n * Detects the GitHub repository from git remote.\n */\nobject RepositoryDetector {\n    \n    /**\n     * Detects repository in format \"owner/repo\" from git remote.\n     * \n     * Returns null if:\n     * - Not in a git repository\n     * - No origin remote configured\n     * - Origin is not a GitHub URL\n     */\n    suspend fun detectRepository(): String? = withContext(Dispatchers.IO) {\n        try {\n            val process = ProcessBuilder(\"git\", \"remote\", \"get-url\", \"origin\")\n                .redirectErrorStream(false)\n                .start()\n            \n            val output = process.inputStream.bufferedReader().readText().trim()\n            val exitCode = process.waitFor()\n            \n            if (exitCode != 0 || output.isBlank()) {\n                return@withContext null\n            }\n            \n            parseRepoFromUrl(output)\n        } catch (e: Exception) {\n            null\n        }\n    }\n    \n    /**\n     * Parses owner/repo from various GitHub URL formats:\n     * - https://github.com/owner/repo.git\n     * - git@github.com:owner/repo.git\n     * - https://github.com/owner/repo\n     */\n    internal fun parseRepoFromUrl(url: String): String? {\n        val patterns = listOf(\n            Regex(\"github\\\\.com[:/]([^/]+)/([^/\\\\.]+)(?:\\\\.git)?\"),\n        )\n        \n        for (pattern in patterns) {\n            pattern.find(url)?.let { match ->\n                val owner = match.groupValues[1]\n                val repo = match.groupValues[2]\n                return \"$owner/$repo\"\n            }\n        }\n        \n        return null\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] `detectRepository()` returns correct value in ampere repo\n- [ ] Returns null when not in a git repo\n- [ ] Handles HTTPS and SSH URL formats\n- [ ] Unit tests cover all URL formats\n\n## Files to Create\n\n- `ampere-core/src/jvmMain/kotlin/link/socket/ampere/integrations/git/RepositoryDetector.kt`\n- `ampere-core/src/jvmTest/kotlin/link/socket/ampere/integrations/git/RepositoryDetectorTest.kt`",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": []
    },
    {
      "localId": "auto-work-loop-create-class",
      "type": "Task",
      "title": "Create AutonomousWorkLoop class with polling logic",
      "body": "## Context\n\nWe need a dedicated class that manages the autonomous work loop - continuously polling for issues, managing the work lifecycle, and handling errors gracefully.\n\n## Objective\n\nCreate `AutonomousWorkLoop` class that encapsulates the polling logic, backoff strategy, and lifecycle management.\n\n## Implementation Details\n\n**New file**: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/execution/AutonomousWorkLoop.kt`\n\n```kotlin\npackage link.socket.ampere.agents.execution\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport link.socket.ampere.agents.definition.CodeAgent\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.minutes\nimport kotlin.time.Duration.Companion.seconds\n\n/**\n * Configuration for autonomous work loop behavior.\n */\ndata class WorkLoopConfig(\n    val maxConcurrentIssues: Int = 1,\n    val maxExecutionTimePerIssue: Duration = 30.minutes,\n    val maxIssuesPerHour: Int = 10,\n    val pollingInterval: Duration = 30.seconds,\n    val backoffInterval: Duration = 5.minutes,\n)\n\n/**\n * Manages autonomous work loop for CodeAgent.\n * \n * Continuously polls for available issues and executes the full\n * issue-to-PR workflow.\n */\nclass AutonomousWorkLoop(\n    private val agent: CodeAgent,\n    private val config: WorkLoopConfig = WorkLoopConfig(),\n    private val scope: CoroutineScope,\n) {\n    private val _isRunning = MutableStateFlow(false)\n    val isRunning: StateFlow<Boolean> = _isRunning.asStateFlow()\n    \n    private var job: Job? = null\n    private var issuesProcessedThisHour = 0\n    private var hourStartTime = System.currentTimeMillis()\n    \n    /**\n     * Start the autonomous work loop.\n     */\n    fun start() {\n        if (_isRunning.value) return\n        \n        job = scope.launch {\n            _isRunning.value = true\n            var consecutiveNoWork = 0\n            \n            while (_isRunning.value) {\n                try {\n                    // Rate limit check\n                    if (shouldThrottleForRateLimit()) {\n                        delay(config.backoffInterval)\n                        continue\n                    }\n                    \n                    // Discover available issues\n                    val issues = agent.queryAvailableIssues()\n                    \n                    if (issues.isEmpty()) {\n                        consecutiveNoWork++\n                        val backoff = calculateBackoff(consecutiveNoWork)\n                        delay(backoff)\n                        continue\n                    }\n                    \n                    consecutiveNoWork = 0\n                    \n                    // Try to claim and work on first issue\n                    val issue = issues.first()\n                    val claimed = agent.claimIssue(issue.number)\n                    \n                    if (claimed.isFailure) {\n                        // Another agent claimed it, continue to next\n                        delay(config.pollingInterval)\n                        continue\n                    }\n                    \n                    // Work on the issue\n                    agent.workOnIssue(issue)\n                    issuesProcessedThisHour++\n                    \n                    delay(config.pollingInterval)\n                    \n                } catch (e: Exception) {\n                    // Log error and continue\n                    delay(config.backoffInterval)\n                }\n            }\n            \n            _isRunning.value = false\n        }\n    }\n    \n    /**\n     * Stop the autonomous work loop.\n     */\n    fun stop() {\n        _isRunning.value = false\n        job?.cancel()\n    }\n    \n    private fun calculateBackoff(consecutiveNoWork: Int): Duration {\n        // Exponential backoff: 30s, 1m, 2m, 5m (capped)\n        val seconds = minOf(\n            30 * kotlin.math.pow(2.0, consecutiveNoWork.toDouble()).toLong(),\n            300\n        )\n        return seconds.seconds\n    }\n    \n    private fun shouldThrottleForRateLimit(): Boolean {\n        val now = System.currentTimeMillis()\n        val hourElapsed = (now - hourStartTime) > 3600_000\n        \n        if (hourElapsed) {\n            hourStartTime = now\n            issuesProcessedThisHour = 0\n            return false\n        }\n        \n        return issuesProcessedThisHour >= config.maxIssuesPerHour\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] Class compiles and integrates with CodeAgent\n- [ ] `start()` begins polling loop\n- [ ] `stop()` gracefully cancels loop\n- [ ] Exponential backoff works correctly\n- [ ] Rate limiting prevents runaway execution\n- [ ] Unit tests verify lifecycle and backoff logic\n\n## Files to Create\n\n- `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/execution/AutonomousWorkLoop.kt`\n- `ampere-core/src/commonTest/kotlin/link/socket/ampere/agents/execution/AutonomousWorkLoopTest.kt`",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-wire-provider", "auto-work-loop-repo-detect"]
    },
    {
      "localId": "auto-work-loop-claim-issue",
      "type": "Task",
      "title": "Implement claimIssue with optimistic locking",
      "body": "## Context\n\nWhen multiple CodeAgent instances run simultaneously, they could race to claim the same issue. We need optimistic locking using GitHub labels to prevent this.\n\n## Objective\n\nAdd `claimIssue()` method to CodeAgent that atomically claims an issue using label updates and verifies the claim succeeded.\n\n## Implementation Details\n\n**File**: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/CodeAgent.kt`\n\n**Add method**:\n```kotlin\n/**\n * Attempt to claim an unassigned issue.\n * \n * Uses optimistic locking: updates issue to CLAIMED status, then\n * verifies we successfully claimed it (no race condition).\n * \n * @return Success if claimed, Failure if another agent claimed it first\n */\nsuspend fun claimIssue(issueNumber: Int): Result<Unit> {\n    val provider = issueTrackerProvider\n        ?: return Result.failure(IllegalStateException(\"IssueTrackerProvider not configured\"))\n    val repo = repository\n        ?: return Result.failure(IllegalStateException(\"Repository not configured\"))\n    \n    try {\n        // 1. Read current issue state\n        val currentIssue = provider.queryIssues(\n            repository = repo,\n            query = IssueQuery(\n                state = IssueState.Open,\n                limit = 100,\n            ),\n        ).getOrNull()?.find { it.number == issueNumber }\n            ?: return Result.failure(IllegalArgumentException(\"Issue #$issueNumber not found\"))\n        \n        // 2. Check if already claimed\n        val currentStatus = IssueWorkflowStatus.fromLabels(currentIssue.labels)\n        if (currentStatus != null && currentStatus != IssueWorkflowStatus.CLAIMED) {\n            return Result.failure(\n                IllegalStateException(\"Issue already claimed or in progress\")\n            )\n        }\n        \n        // 3. Update to CLAIMED status\n        val updateResult = updateIssueStatus(\n            issueNumber = issueNumber,\n            status = IssueWorkflowStatus.CLAIMED,\n            comment = \"CodeAgent claiming this issue\",\n        )\n        \n        if (updateResult.isFailure) {\n            return Result.failure(\n                updateResult.exceptionOrNull() ?: Exception(\"Failed to claim issue\")\n            )\n        }\n        \n        // 4. Verify we got it (check for race condition)\n        // Small delay to let GitHub propagate the update\n        kotlinx.coroutines.delay(500)\n        \n        val verifiedIssue = provider.queryIssues(\n            repository = repo,\n            query = IssueQuery(\n                state = IssueState.Open,\n                limit = 100,\n            ),\n        ).getOrNull()?.find { it.number == issueNumber }\n        \n        val finalStatus = IssueWorkflowStatus.fromLabels(verifiedIssue?.labels ?: emptyList())\n        \n        if (finalStatus != IssueWorkflowStatus.CLAIMED) {\n            return Result.failure(\n                IllegalStateException(\"Race condition: another agent claimed the issue\")\n            )\n        }\n        \n        return Result.success(Unit)\n        \n    } catch (e: Exception) {\n        return Result.failure(e)\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] Single agent can successfully claim unassigned issue\n- [ ] Race condition detection works (simulated with two concurrent claims)\n- [ ] Already-claimed issues return failure\n- [ ] Issues in other states (in-progress, blocked) return failure\n- [ ] Unit tests verify all scenarios\n\n## Files to Modify\n\n- `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/CodeAgent.kt` (add method after `updateIssueStatus`)\n- `ampere-core/src/jvmTest/kotlin/link/socket/ampere/agents/definition/CodeAgentIntegrationTest.kt` (add tests)",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-create-class"]
    },
    {
      "localId": "auto-work-loop-work-pipeline",
      "type": "Task",
      "title": "Implement workOnIssue full pipeline",
      "body": "## Context\n\nCodeAgent has all the pieces for the issue-to-PR workflow, but needs a top-level orchestration method that runs the complete pipeline from start to finish.\n\n## Objective\n\nAdd `workOnIssue()` method to CodeAgent that executes the full autonomous workflow:\n1. Update status to IN_PROGRESS\n2. Create implementation plan\n3. Execute plan steps\n4. Create PR\n5. Update status to IN_REVIEW\n6. Handle errors appropriately\n\n## Implementation Details\n\n**File**: `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/CodeAgent.kt`\n\n**Add method**:\n```kotlin\n/**\n * Work on a claimed issue through the full pipeline.\n * \n * Executes: IN_PROGRESS → Plan → Execute → Create PR → IN_REVIEW\n * \n * @param issue The issue to work on (must already be claimed)\n * @return Success if PR created, appropriate error status otherwise\n */\nsuspend fun workOnIssue(\n    issue: link.socket.ampere.integrations.issues.ExistingIssue\n): Result<String> {\n    try {\n        // 1. Update to IN_PROGRESS\n        updateIssueStatusSafely(\n            issueNumber = issue.number,\n            status = IssueWorkflowStatus.IN_PROGRESS,\n            comment = \"Starting implementation\",\n        )\n        \n        // 2. Create task from issue\n        val task = Task.CodeChange(\n            id = \"issue-${issue.number}\",\n            status = link.socket.ampere.agents.domain.status.TaskStatus.Pending,\n            description = buildString {\n                appendLine(\"# ${issue.title}\")\n                appendLine()\n                appendLine(issue.body)\n                appendLine()\n                appendLine(\"Issue: ${issue.url}\")\n            },\n        )\n        \n        // 3. Create implementation plan\n        val perception = perceiveState(task)\n        val idea = reason(perception, task)\n        val plan = createPlan(idea, task)\n        \n        // 4. Execute the plan\n        val outcome = executePlan(plan, task)\n        \n        // 5. Check if execution succeeded\n        if (outcome !is link.socket.ampere.agents.domain.outcome.ExecutionOutcome.CodeChanged.Success) {\n            // Mark as blocked\n            updateIssueStatusSafely(\n                issueNumber = issue.number,\n                status = IssueWorkflowStatus.BLOCKED,\n                comment = \"Execution failed: ${outcome}\",\n            )\n            return Result.failure(Exception(\"Execution failed: $outcome\"))\n        }\n        \n        // 6. Create PR (this should happen during plan execution)\n        // Status should already be updated to IN_REVIEW by executeGitCreatePRStep\n        \n        return Result.success(\"Issue #${issue.number} completed successfully\")\n        \n    } catch (e: Exception) {\n        // Mark as blocked on any error\n        updateIssueStatusSafely(\n            issueNumber = issue.number,\n            status = IssueWorkflowStatus.BLOCKED,\n            comment = \"Error: ${e.message}\",\n        )\n        return Result.failure(e)\n    }\n}\n```\n\n## Validation Criteria\n\n- [ ] End-to-end test: claim issue → work → PR created → status IN_REVIEW\n- [ ] Errors properly caught and marked as BLOCKED\n- [ ] Issue status transitions are correct\n- [ ] PR body includes \"Closes #N\"\n- [ ] Integration test validates full workflow\n\n## Files to Modify\n\n- `ampere-core/src/commonMain/kotlin/link/socket/ampere/agents/definition/CodeAgent.kt` (add method)\n- `ampere-core/src/jvmTest/kotlin/link/socket/ampere/agents/definition/CodeAgentIntegrationTest.kt` (enable full workflow test)",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-claim-issue"]
    },
    {
      "localId": "auto-work-loop-ampere-context",
      "type": "Task",
      "title": "Integrate AutonomousWorkLoop into AmpereContext",
      "body": "## Context\n\nAmpereContext is the central dependency injection container. We need to add AutonomousWorkLoop creation and lifecycle management here.\n\n## Objective\n\nAdd factory methods to AmpereContext for creating and managing AutonomousWorkLoop instances.\n\n## Implementation Details\n\n**File**: `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/AmpereContext.kt`\n\n**Add to AmpereContext class**:\n```kotlin\nimport link.socket.ampere.agents.execution.AutonomousWorkLoop\nimport link.socket.ampere.agents.execution.WorkLoopConfig\n\n// Add property\nprivate var _autonomousWorkLoop: AutonomousWorkLoop? = null\nval autonomousWorkLoop: AutonomousWorkLoop\n    get() = _autonomousWorkLoop ?: error(\"Autonomous work loop not initialized\")\n\n/**\n * Create and start autonomous work loop for CodeAgent.\n */\nfun createAutonomousWorkLoop(\n    agent: link.socket.ampere.agents.definition.CodeAgent,\n    config: WorkLoopConfig = WorkLoopConfig(),\n): AutonomousWorkLoop {\n    if (_autonomousWorkLoop != null) {\n        return _autonomousWorkLoop!!\n    }\n    \n    val loop = AutonomousWorkLoop(\n        agent = agent,\n        config = config,\n        scope = kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.Default),\n    )\n    \n    _autonomousWorkLoop = loop\n    return loop\n}\n\n/**\n * Start autonomous work mode.\n */\nfun startAutonomousWork() {\n    _autonomousWorkLoop?.start()\n        ?: error(\"Autonomous work loop not initialized. Call createAutonomousWorkLoop first.\")\n}\n\n/**\n * Stop autonomous work mode.\n */\nfun stopAutonomousWork() {\n    _autonomousWorkLoop?.stop()\n}\n\n// Update close() method to stop work loop\noverride fun close() {\n    stopAutonomousWork()\n    // ... existing cleanup code\n}\n```\n\n**Update Main.kt**:\n```kotlin\n// After creating agents\nval codeAgent = agentFactory.create<CodeAgent>(AgentType.CODE)\n\n// Create work loop (but don't start yet)\ncontext.createAutonomousWorkLoop(codeAgent)\n```\n\n## Validation Criteria\n\n- [ ] `createAutonomousWorkLoop()` creates loop successfully\n- [ ] `startAutonomousWork()` starts the polling\n- [ ] `stopAutonomousWork()` stops cleanly\n- [ ] `close()` properly cleans up work loop\n- [ ] Integration test validates lifecycle\n\n## Files to Modify\n\n- `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/AmpereContext.kt` (add methods)\n- `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/Main.kt` (initialize work loop)",
      "labels": ["task", "code"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-work-pipeline"]
    },
    {
      "localId": "auto-work-loop-cli-commands",
      "type": "Task",
      "title": "Implement CLI commands for autonomous work",
      "body": "## Context\n\nWe have a WorkCommand skeleton but it's not implemented. We also need to add `--auto-work` flag to StartCommand for background autonomous mode.\n\n## Objective\n\nImplement the CLI commands to control autonomous work:\n1. `ampere work` - Work on one issue\n2. `ampere work --continuous` - Keep working\n3. `ampere start --auto-work` - Dashboard + autonomous mode\n\n## Implementation Details\n\n### Part 1: Implement WorkCommand\n\n**File**: `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/WorkCommand.kt`\n\nReplace the TODO section with actual implementation:\n```kotlin\noverride fun run() = runBlocking {\n    val context = contextProvider()\n    \n    terminal.println(bold(cyan(\"⚡ AMPERE Autonomous Work Mode\")))\n    // ... existing config output ...\n    \n    if (dryRun) {\n        // Show what would happen\n        val issues = context.codeAgent.queryAvailableIssues()\n        terminal.println(\"Would work on ${issues.size} available issue(s)\")\n        issues.take(5).forEach { issue ->\n            terminal.println(\"  #${issue.number}: ${issue.title}\")\n        }\n        return@runBlocking\n    }\n    \n    if (continuous) {\n        // Start work loop\n        context.startAutonomousWork()\n        \n        terminal.println(green(\"Autonomous work mode started\"))\n        terminal.println(\"Press Ctrl+C to stop\")\n        \n        // Wait for user interrupt\n        Runtime.getRuntime().addShutdownHook(Thread {\n            runBlocking { context.stopAutonomousWork() }\n        })\n        \n        // Block until interrupted\n        while (context.autonomousWorkLoop.isRunning.value) {\n            delay(1000)\n        }\n    } else {\n        // Work on single issue\n        val issues = context.codeAgent.queryAvailableIssues()\n        \n        if (issues.isEmpty()) {\n            terminal.println(yellow(\"No available issues found\"))\n            return@runBlocking\n        }\n        \n        val issue = issueNumber?.let { num ->\n            issues.find { it.number == num }\n        } ?: issues.first()\n        \n        terminal.println(\"Working on issue #${issue.number}: ${issue.title}\")\n        \n        val claimed = context.codeAgent.claimIssue(issue.number)\n        if (claimed.isFailure) {\n            terminal.println(red(\"Failed to claim issue: ${claimed.exceptionOrNull()?.message}\"))\n            return@runBlocking\n        }\n        \n        val result = context.codeAgent.workOnIssue(issue)\n        if (result.isSuccess) {\n            terminal.println(green(\"✓ Successfully completed issue #${issue.number}\"))\n        } else {\n            terminal.println(red(\"✗ Failed: ${result.exceptionOrNull()?.message}\"))\n        }\n    }\n}\n```\n\n### Part 2: Add --auto-work to StartCommand\n\n**File**: `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/StartCommand.kt`\n\nAdd flag:\n```kotlin\nprivate val autoWork by option(\n    \"--auto-work\",\n    help = \"Start autonomous work mode in background\"\n).flag(default = false)\n```\n\nIn run() method, after dashboard starts:\n```kotlin\nif (autoWork) {\n    context.startAutonomousWork()\n    // Dashboard will show work happening\n}\n```\n\n## Validation Criteria\n\n- [ ] `ampere work` works on single issue\n- [ ] `ampere work --continuous` keeps working until stopped\n- [ ] `ampere work --dry-run` shows available issues without claiming\n- [ ] `ampere start --auto-work` runs dashboard with autonomous mode\n- [ ] Ctrl+C gracefully stops work loop\n\n## Files to Modify\n\n- `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/WorkCommand.kt` (implement logic)\n- `ampere-cli/src/jvmMain/kotlin/link/socket/ampere/StartCommand.kt` (add flag)",
      "labels": ["task", "code", "cli"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-ampere-context"]
    },
    {
      "localId": "auto-work-loop-integration-tests",
      "type": "Task",
      "title": "End-to-end integration tests for autonomous work",
      "body": "## Context\n\nWe have unit tests for individual components, but need end-to-end integration tests that validate the complete autonomous workflow.\n\n## Objective\n\nCreate comprehensive integration tests that validate:\n1. Full workflow from discovery to PR creation\n2. Error handling and recovery\n3. Race condition handling\n4. Work loop lifecycle\n\n## Implementation Details\n\n**File**: `ampere-core/src/jvmTest/kotlin/link/socket/ampere/agents/definition/CodeAgentAutonomousWorkflowTest.kt`\n\n**Test cases**:\n```kotlin\nclass CodeAgentAutonomousWorkflowTest {\n    \n    @Test\n    fun `autonomous workflow - single issue end-to-end`() = runTest {\n        // 1. Create test issue with 'code' label\n        // 2. Start work loop\n        // 3. Verify agent discovers issue\n        // 4. Verify agent claims issue (status → CLAIMED)\n        // 5. Verify agent starts work (status → IN_PROGRESS)\n        // 6. Verify code written, branch created, committed\n        // 7. Verify PR created\n        // 8. Verify status updated to IN_REVIEW\n    }\n    \n    @Test\n    fun `autonomous workflow - handles execution failure`() = runTest {\n        // 1. Create issue that will fail (e.g., invalid code request)\n        // 2. Start work loop\n        // 3. Verify agent discovers and claims issue\n        // 4. Verify execution fails\n        // 5. Verify status updated to BLOCKED\n        // 6. Verify loop continues to next issue\n    }\n    \n    @Test\n    fun `autonomous workflow - race condition handling`() = runTest {\n        // 1. Create single issue\n        // 2. Start two agents simultaneously\n        // 3. Verify only one successfully claims\n        // 4. Verify second agent moves to next issue\n    }\n    \n    @Test\n    fun `work loop lifecycle - start and stop`() = runTest {\n        // 1. Create work loop\n        // 2. Verify not running initially\n        // 3. Call start()\n        // 4. Verify isRunning = true\n        // 5. Call stop()\n        // 6. Verify isRunning = false\n        // 7. Verify graceful shutdown\n    }\n    \n    @Test\n    fun `work loop - exponential backoff when no issues`() = runTest {\n        // 1. Start work loop with no issues available\n        // 2. Measure polling intervals\n        // 3. Verify exponential backoff (30s → 1m → 2m → 5m)\n    }\n    \n    @Test\n    fun `work loop - rate limiting prevents runaway`() = runTest {\n        // 1. Create 20 issues\n        // 2. Start work loop with maxIssuesPerHour = 5\n        // 3. Verify only 5 processed in first hour\n        // 4. Verify loop backs off\n    }\n}\n```\n\n**Enable existing placeholder tests**:\n\nIn `CodeAgentIntegrationTest.kt`, remove `@Ignore` from:\n- `INTEGRATION - agent completes full issue-to-PR workflow`\n- `INTEGRATION - agent addresses PR review feedback`\n\nUpdate these tests with actual implementation now that Git tools are working.\n\n## Validation Criteria\n\n- [ ] All integration tests pass\n- [ ] Tests run in CI/CD pipeline\n- [ ] Code coverage > 80% for new code\n- [ ] Tests validate success and failure paths\n- [ ] Tests run in reasonable time (< 5 minutes total)\n\n## Files to Create/Modify\n\n- `ampere-core/src/jvmTest/kotlin/link/socket/ampere/agents/definition/CodeAgentAutonomousWorkflowTest.kt` (new)\n- `ampere-core/src/jvmTest/kotlin/link/socket/ampere/agents/definition/CodeAgentIntegrationTest.kt` (enable tests)",
      "labels": ["task", "code", "testing"],
      "assignees": [],
      "parent": "auto-work-loop-epic",
      "dependsOn": ["auto-work-loop-cli-commands"]
    }
  ]
}
